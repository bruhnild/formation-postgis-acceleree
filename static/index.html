<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Formation PostgreSQL / PostGIS</title>
    <link rel="shortcut icon" href="./favicon.ico"/>
    <link rel="stylesheet" href="./dist/reveal.css" />
    <link rel="stylesheet" href="_assets/assets/makina-theme/makina-formation.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/zenburn.css" />

  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section ><section data-markdown><script type="text/template">

<!-- .slide: class="title logo" data-background="#b5b42c" -->

# PostgreSQL / PostGIS

<!-- formateur@makina-corpus.com -->

![](assets/images/postgis-logo.png)



</script></section><section data-markdown><script type="text/template">

<!-- .slide: class="title logo" data-background="#b5b42c" -->

# Makina Corpus

* Soci√©t√© de Services en Logiciels Libres (SSLL)
* D√©veloppement d‚Äôapplications web et mobile
(application m√©tier, front-end, cartographie, CMS, mobile, data)
* Audits
* Formation
* Pr√©sente notamment √† Toulouse et Nantes


</script></section></section><section  data-markdown><script type="text/template">## Objectifs de la formation

<img src="assets/images/objectifs.png" width="200">

- √âtendre les fonctionnalit√©s d'une base de donn√©es
- Concevoir une base de donn√©es spatiale
- Exploiter une base de donn√©es spatiale
- Installer et administrer une base de donn√©es spatiale


</script></section><section ><section data-markdown><script type="text/template">## Organisation
- 3 jours
- Horaires : 9h00 - 12h30 / 13h30 - 17h00

<iframe src="https://giphy.com/embed/d3yxg15kJppJilnW" width="200" height="200" frameBorder="0" class="giphy-embed" allowFullScreen></iframe><p><a href="https://giphy.com/gifs/time-clock-konczakowski-d3yxg15kJppJilnW"></a></p>

</script></section><section data-markdown><script type="text/template">

### Fonctionnement de la formation
#### Alternance de :
- Pr√©sentations th√©oriques et discussions autour de probl√©matiques
m√©tier
- Mises en pratique
- Travaux coop√©ratifs ou individuels

</script></section><section data-markdown><script type="text/template">

### Cadre pour ces 3 jours
- Confiance et confidentialit√©.
- Libre verbalisation, confrontation positive.
- Corresponsabilit√© dans l'atteinte des objectifs.
- Ponctualit√©, assiduit√© et t√©l√©phones silencieux.

Programme souple, posez des questions, exprimez-vous¬†!

¬Ø\\_(„ÉÑ)_/¬Ø
</script></section></section><section ><section data-markdown><script type="text/template">## Programme

### 1er jour
- Pr√©sentation de l'architecture PostgreSQL
- Pr√©sentation des clients PostgreSQL
- Installation de PostGIS
- Exploitation de la dimension spatiale

</script></section><section data-markdown><script type="text/template">

### 2√®me jour
- Conception d'une base de donn√©es
- Manipulation d'enregistrements en SQL
- Entretien d'une base de donn√©es
- Manipulation de donn√©es raster

</script></section><section data-markdown><script type="text/template">

### 3√®me jour
- Gestion de la topologie et routing
- Administration d'une base de donn√©es
- Notions SQL avanc√©es
</script></section></section><section ><section data-markdown><script type="text/template">## Qu'est ce qu'une base de donn√©es ?

<img src="assets/images/database.png" width="200">

Ensemble qui va permettre de stocker des donn√©es.

- Les donn√©es
- Le SGBD


</script></section><section data-markdown><script type="text/template">

### Structure des donn√©es

- Banque de donn√©es
- Bases de donn√©es
- Tables
- Enregistrements

</script></section><section data-markdown><script type="text/template">

### El√©ments du SGBD

- Le moteur SQL va r√©aliser toutes les manipulations sur les fichiers de donn√©es
- Le catalogue va contenir la description de la bdd et les informations des utilisateurs
- Le langage de requ√™tes (le SQL)
- Le processeur de requ√™tes (commande pour le moteur SQL)

</script></section><section data-markdown><script type="text/template">


## Un mot sur le SQL

### Structured Query Langage

- Langage permettant de communiquer avec une base de donn√©es
- Commandes proches du langage naturel
- Quelque soit le SGBD utilis√© (PostgreSQL, Oracle, MySQL..), on retrouvera la m√™me syntaxe.

</script></section><section data-markdown><script type="text/template">

#### Quatres grandes parties

- Langage de manipulation de donn√©es (LMD):
	- __INSERT__ (ajout de ligne)
	- __UPDATE__ (mise √† jour de ligne)
	- __DELETE__ (suppression de ligne)
	- __SELECT__ (consultation de donn√©es)

- Langage de controle de donn√©es (LCD):
	- __GRANT__ (affectation, des droits)
	- __REVOKE__ (suppression des droits)

- Langage de d√©finition de donn√©es (LDD) :
	- __CREATE__ (cr√©ation d'objet)
	- __ALTER__ (modification d'objet)
	- __DROP__ (destruction d'objet)

</script></section><section data-markdown><script type="text/template">
#### Quatres grandes parties (suite)

- Langage de controle de transaction (LCT) :
	- __COMMIT__ (validation de modification de bdd)
	- __ROLLBACK__ (annulation de modification de bdd)

</script></section><section data-markdown><script type="text/template">

#### Comment se lit une requ√™te SQL?

**SELECT‚Äã** est une commande SQL qui permet d'extraire des donn√©es provenant des tables ou des vues d'une base de donn√©es relationnelle.

</script></section><section data-markdown><script type="text/template">
Une commande **SELECT**  a g√©n√©ralement cette syntaxe l√† :

```sql
SELECT attributs
FROM tables
WHERE conditions -- optionnelle
GROUP BY attributs -- optionnelle
HAVING conditions -- optionnelle
ORDER BY attributs -- optionnelle
LIMIT nombre -- optionnelle
```

et se lit

```sql
FROM tables
WHERE conditions -- optionnelle
SELECT attributs
GROUP BY attributs -- optionnelle
HAVING conditions -- optionnelle
ORDER BY attributs -- optionnelle
LIMIT nombre -- optionnelle
```
</script></section><section data-markdown><script type="text/template">

- La partie ```SELECT``` indique les colonnes et expressions qui seront extraites. *Les colonnes list√©es dans le __SELECT__ doivent appartenir aux tables/vues/sous-requ√™tes list√©es dans le __FROM__.*
- La partie ```FROM``` d√©crit les tables/vues/sous-requ√™tes qui serviront de sources de donn√©es.
- La partie ```WHERE``` (*optionnelle*) exprime les conditions de s√©lection des enregistrements.
- La partie ```GROUP BY``` (*optionnelle*) permet, via les noms des colonnes et expressions, de grouper les r√©sultats (agr√©gats). ‚Äã

</script></section><section data-markdown><script type="text/template">


- La partie ```HAVING``` (*optionnelle*) exprime les conditions de s√©lection sur des r√©sultats aggr√©g√©s. Il se diff√©rencie du ```WHERE``` par le fait que le __WHERE__ est utilis√© avant le __GROUP BY__ et que le ```HAVING``` est utilis√© apr√®s aggr√©gation par le __GROUP BY__.
- La partie ```ORDER BY``` permet de trier les r√©sultats par ordre croissant (par d√©faut) ou d√©croissant (```DESC```)
- La partie ```LIMIT``` permet de restreindre le nombre de r√©sultats

üëâ Pour des exemples, se rendre sur la page [Wikipedia](https://fr.wikipedia.org/wiki/Select_(SQL))





</script></section></section><section ><section data-markdown><script type="text/template">## PostgreSQL

<img src="assets/images/postgresql_logo.png" width="300">
</script></section><section data-markdown><script type="text/template">
### Historique

- PostgreSQL est un Syst√®me de Gestion de Bases de Donn√©es (SGBD) de type relationnel.
 - Relationnel : structure _carr√©e_ telle que celle d'un tableur (ligne, colonnes)
- √âvolution de Ingres, d√©marr√© en 1977.
- D√©but du d√©veloppement en 1985 √† l'universit√© de Berkeley par Michael Stonebraker
- Libre et open source
- Le nom PostgreSQL apparait en 1995
- Projet repris en Open Source par une communaut√© de d√©veloppeurs
 support√©e par de nombreuses entreprises.
- Derni√®re version : 13


</script></section><section data-markdown><script type="text/template">

### Cas d'utilisation

- PostgreSQL est g√©n√©ralement utilis√© comme couche de persistance
 dans des applications m√©tiers o√π :
    - le volume de donn√©es est important (jusqu'√† plusieurs t√©raoctets),
    - l'int√©grit√© des donn√©es est un imp√©ratif majeur,
    - la charge envisag√©e est importante,
    - les requ√™tes sont complexes.

üëâ Le site de la communaut√© [PostgreSQL-fr](https://www.postgresql.fr/) liste diff√©rents
 t√©moignages.


</script></section><section data-markdown><script type="text/template">

### Atouts

- Stockage d'information plus structur√©e qu'avec une arborescence de fichiers SHP
- Robuste
- G√®re des gros volumes de donn√©es (PCI, r√©f√©rentiels..)
- Gestion des relations entre donn√©es g√©ographiques et donn√©es attributaires
- Permet de d√©velopper des applications m√©tiers
- Gestion fine des droits d'acc√®s
- Fonctionne sur les principaux syst√®mes d'exploitation

</script></section><section data-markdown><script type="text/template">

### Atouts

- Supporte de nombreux langages (Java, Python, Perl, Json, Ruby, C++)
- Contr√¥le d'acc√®s simultan√© (mod√®le MVCC)
- Contraintes d'int√©grit√©
- Extensible (par exemple¬†: PostGIS)
- Mod√®le client/serveur et multi-utilisateurs
- Conforme au standard SQL, augment√© de syntaxes sp√©cifiques
- Bon bin√¥me avec Qgis
- Support√© par une communaut√© large et active


</script></section><section data-markdown><script type="text/template">

### Points faibles

- N√©cessite des comp√©tences en administration syst√®me :
 - Installation, configuration, sauvegardes/restaurations
- Vigilance sur le long terme sur la performance (autovacuum, index, espace disque)

 </script></section><section data-markdown><script type="text/template">

### Ce qu'apporte la derni√®re version de Postgres

<img src="assets/images/postgres12.png" width="300">

#### Am√©lioration de la performance
- R√©duction de l'espace utilis√© par les index
- Syst√®me de tri incr√©mental (r√©utilisation des pr√©c√©dents tris de r√©sultats)
- M√©canisme d'agr√©gation par hachage (utilisation d'une cl√© au lieu des donn√©es compl√®tes)

#### Am√©lioration sur la maintenance
- Parall√©lisation du _VACUUM_ sur les index
- Plans d'ex√©cutions plus d√©taill√©s

#### Am√©lioration de la s√©curit√©
- Extensions de confiance activables par utilisateurs classiques

üëâ Voir cet [article](https://blog.dalibo.com/2020/09/25/release_postgresql_13.html) pour plus de d√©tails




</script></section></section><section ><section data-markdown><script type="text/template">## PostGIS


![](assets/images/postgis-logo.png)
</script></section><section data-markdown><script type="text/template">

### Pr√©sentation

- PostGIS est l'extension spatiale de PostgreSQL.
- Elle y int√®gre :
  - des types de donn√©es pour repr√©senter de l'information g√©o-localis√©e: geometry / geography
  - un ensemble de fonctions et op√©rateurs pour manipuler ces informations g√©o-localis√©es.
- PostGIS est apparu en 2001 au sein de la soci√©t√© canadienne Refractions.
- PostGIS impl√©mente les normes OGC Simple Feature (SQL/MM)
- Derni√®re version : 3.1.1

</script></section><section data-markdown><script type="text/template">

### Caract√©ristiques

- PostGIS fournit plus de 1000 objets pour l'analyse spatiale vectorielle
 : types, op√©rateurs, fonctions.
- Ces objets forment le vocabulaire pour poser des questions spatiales
 √† PostgreSQL.
- Comme PostgreSQL, PostGIS peut √™tre utilis√© dans des environnements
 tr√®s vari√©s : Web, serveur local, applications bureautiques, etc...


</script></section><section data-markdown><script type="text/template">

### Ce qu'apporte la derni√®re version de PostGIS

- G√©n√©ration de grilles carr√©s ou hexagonales
- Am√©lioration de la performance de diverses fonctions (TopoJSON, ST_AsMVT)
</script></section></section><section ><section data-markdown><script type="text/template">## L'univers des moteurs SQL
<img src="assets/images/moteurssql.jpeg" >

</script></section><section data-markdown><script type="text/template">
<img src="assets/images/MySQL.png" width="200">
<img src="assets/images/mariadb.jpg" width="200">

### PostgreSQL vs. MySQL / MariaDB


- MySQL et MariaDB (alternative open source) sont con√ßus pour le Web¬†: requ√™tes simples, temps de r√©ponse
 minimaux.
- Support limit√© des contraintes d'int√©grit√©.
- MySQL/MariaDB s'occupent tr√®s bien des petits jeux de donn√©es avec un faible nombre d'utilisateurs
- Poss√®de moins de fonctionnalit√©s que Postgres

</script></section><section data-markdown><script type="text/template">

<img src="assets/images/msaccess.png" width="200">

### PostgreSQL vs. MS Access

- MS Access permet de construire des applications m√©tiers simples avec
 relativement peu de comp√©tences en informatique.
- MS Access n'est pas un serveur.
- Gestion de bases de faible taille (500 mo)
- Gestion rudimentaire des utilisateurs et des droits.
- Support limit√© du SQL, interfaces non standards, portabilit√©
 limit√©e.
- Pas d'extension spatiale.
- Plut√¥t destin√© √† des applications mono-postes.

</script></section><section data-markdown><script type="text/template">

<img src="assets/images/oracle.png" width="200">

### PostgreSQL vs. Oracle

- PostgreSQL est g√©n√©ralement pr√©sent√© comme l'√©quivalent Libre
 d'Oracle.
- Bien avant les d√©tails techniques, il s'agit d'un choix entre une
 solution Libre et une solution propri√©taire.
- Support garanti¬†? Support communautaire¬†?
- Postgres reste facilement administrable, l√† o√π Oracle requiert un sp√©cialiste et repr√©sente un co√ªt suppl√©mentaire

</script></section><section data-markdown><script type="text/template">

<img src="assets/images/SQLite.png" width="200">

### PostgreSQL vs. SQLite3

- [SpatiaLite](https://www.gaia-gis.it/fossil/libspatialite/index) est l'extension spatiale de SQLite.
- Extr√™mement l√©ger et facile √† mettre en ≈ìuvre.
- Spatialite n'est pas un serveur.
- Base stock√©e dans un fichier facilement duplicable, d√©placable.
- Respect des standards (SQL et Simple Feature).
- Communaut√© dynamique pour SQLite mais embryonnaire pour Spatialite.
- Pas de gestion d'utilisateurs.
</script></section></section><section ><section data-markdown><script type="text/template">## Architecture logicielle

### Client / Serveur

- PostgreSQL est un serveur.
- C'est un programme qui ne poss√®de pas d'interface homme-machine, il
 √©coute/attend seulement les requ√™tes envoy√©es par d'autres
 programmes¬†: les clients.
- Le client se connecte au serveur en sp√©cifiant :
    - le nom d'h√¥te et √©ventuellement son domaine,
    - le port (par d√©faut 5432),
    - un nom d'utilisateur et √©ventuellement un mot de passe.

</script></section><section data-markdown><script type="text/template">

![](assets/images/architecture.jpg)

</script></section><section data-markdown><script type="text/template">

### Architecture

**Un serveur local ou distant s'appelle une `instance`**

<img src="assets/images/architecture_postgres.png" width="1500">
#instance #port #cluster #bdd #schema #table #vue #role

</script></section><section data-markdown><script type="text/template">

### Architecture

#### Focus

<table><tr>
<td> <img src="assets/images/login_pg.png" alt="R√¥les" style="width: 200px;"/> </td>
<td> <img src="assets/images/database_pg.png" alt="Base de donn√©es" style="width: 400px;"/> </td>
</tr></table>
</script></section><section data-markdown><script type="text/template"></script></section></section><section ><section data-markdown><script type="text/template">## Outils

### Clients

- Les biblioth√®ques clientes permettent de communiquer avec le serveur en utilisant un langage de programmation.
- Des applications clientes sont b√¢ties gr√¢ce √† ces biblioth√®ques.

</script></section><section data-markdown><script type="text/template">

|Principaux outils clients| Description |
|----------|:-------------:|
|¬†[psql](https://docs.postgresql.fr/8.2/app-psql.html)¬†|Interface en ligne de commande permettant la saisie de requ√™tes SQL|
|[pgadmin4](https://www.pgadmin.org/)¬†|Outil d'administration graphique pour PostgreSQL|
| [PhpPgAdmin](http://phppgadmin.sourceforge.net/doku.php)|interface web d'administration pour PostgreSQL.|
| [HeiSQL](https://www.heidisql.com/download.php)|Client SQL pour Windows qui supporte les principaux moteurs de bases de donn√©es|
| [DBeaver](http://phppgadmin.sourceforge.net/doku.php)|Client SQL multi plateformes qui supporte les principaux moteurs de bases de donn√©es|
|[QGIS](https://www.qgis.org/fr/site/forusers/download.html) | Logiciel SIG, peut se connecter √† PostgreSQL |

</script></section><section data-markdown><script type="text/template">

### psql

- Client d√©velopp√© au sein m√™me du projet [PostgreSQL](https://www.postgresql.org/), toujours fourni
 avec le serveur.
- Caract√©ristiques :
    - interface en mode console,
    - tr√®s complet dans le sens o√π il permet d'exploiter l'ensemble des
 fonctionnalit√©s de PostgreSQL,
    - dispose d'une multitude de raccourcis facilitant son utilisation
- Peut √™tre utilis√© sur des serveurs ne disposant pas de sortie
 graphique.

</script></section><section data-markdown><script type="text/template">

### psql

![](assets/images/psql.png)

</script></section><section data-markdown><script type="text/template">

### PgAdmin4

- [PgAdmin4](https://www.pgadmin.org/) est le client graphique Open Source le plus √©volu√©. Sous
 Windows, il est install√© par d√©faut avec PostgreSQL.

- Caract√©ristiques :
  - Application web
  - Coloration syntaxique
  - Autocompl√©tion
  - Import/export SQL et CSV
  - Bonne visibilit√© sur l'organisation des donn√©es (tables et vues)
  - Tr√®s complet, permet l'acc√®s √† l'ensemble des objets et fonctionnalit√©s de PostgreSQL
  - Plan d'ex√©cution graphique
  - Plusieurs plugins existent pour visualiser les objets PostGIS.
  - Les derni√®res versions int√®grent un visualiseur de g√©om√©tries.

</script></section><section data-markdown><script type="text/template">

### PgAdmin4

![](assets/images/pgadmin4.png)

</script></section><section data-markdown><script type="text/template">

### phpPgAdmin

- [phpPgAdmin](https://github.com/phppgadmin/phppgadmin) est un fork de phpMyAdmin.
- Caract√©ristiques :
    - application Web, ne n√©cessite qu'un navigateur Web (pas
 d'installation locale),
    - peu ergonomique,
    - tr√®s complet, permet l'acc√®s √† l'ensemble des objets et
 fonctionnalit√©s de PostgreSQL.
- phpPgAdmin est fr√©quemment utilis√© lorsqu'on souhaite donner
 l'acc√®s au serveur √† un public large.
- Projet en mode maintenance, peu d'√©volutions mais des correctifs apport√©s plus ou moins r√©guli√®rement

</script></section><section data-markdown><script type="text/template">

### phpPgAdmin

![](assets/images/phppgadmin.png)

</script></section><section data-markdown><script type="text/template">

### HeidiSQL

- Opensource
- Disponible uniquement sur Windows et sous Linux (par l'interm√©diaire de Wine)
- Supporte MariaDB, MySQL, PostgreSQL
- Coloration syntaxique
- Import/export SQL et CSV
- Autocompl√©tion
- Pas de gestion des transactions

</script></section><section data-markdown><script type="text/template">

![](assets/images/heidisql.jpg)

</script></section><section data-markdown><script type="text/template">

### DBeaver

- Client SQL √©crit en JAVA supportant beaucoup de drivers : MySQL, PostgreSQL, SQLite, Oracle, DB2, SQL Server, Sybase, Teradata, MongoDB, Cassandra, Redis...
- G√©n√®re un diagramme des tables relationnelles
- Coloration syntaxique
- Autocompl√©tion
- Drag and drop des tables
- Visualiseur de g√©om√©trie qui reprojette les donn√©es sur un fond de plan
- Client lourd bas√© sur le framework Eclipse
- Peu document√©

</script></section><section data-markdown><script type="text/template">

<img src="assets/images/dbeaver.png" width="450">


</script></section><section data-markdown><script type="text/template">
### Autres clients

- Il existe de nombreux pilotes pour PostgreSQL :
    - [psycopg](http://initd.org/psycopg/) pour Python,
    - php_pgsql pour PHP,
    - support dans JDBC (Java Database Connectivity),
    - existence d'un [pilote ODBC](https://odbc.postgresql.org/) (Open Database Connectivity).
- Tout programme peut se connecter √† PostgreSQL.
- Les suites bureautiques OpenOffice et MS Office sont capables de se
 connecter via ODBC.

</script></section><section data-markdown><script type="text/template">

### Clients cartographiques

- De nombreux logiciels SIG sont capables de traiter une table PostGIS
 comme une couche vectorielle.
- Dans la sph√®re OpenSource, on peut noter¬†:
    - [QGIS](https://www.qgis.org) dispose d'un connecteur et plusieurs plugins fournissent un
 √©diteur de requ√™te (notamment DBManager),
    - [OpenJUMP](http://www.openjump.org/) ou [UDIG](http://udig.refractions.net/) (Java) disposent d'un connecteur et d'un √©diteur de
 requ√™tes incorpor√©,
    - [TileMill](https://tilemill-project.github.io/tilemill/) permet d'utiliser des requ√™tes comme source de donn√©es pour les feuilles de style.
    - GDAL et son outil [ogr2ogr](https://gdal.org/programs/ogr2ogr.html) permettent d'importer et exporter des donn√©es g√©ographiques de PostGIS en ligne de commande



</script></section><section data-markdown><script type="text/template">

### Pour la suite

Dans cette formation, nous nous concentrerons sur l'utilisation de :
* PostgreSQL et PostGIS via PgAdmin4,
* Qgis pour la partie cartographique.

</script></section></section><section ><section data-markdown><script type="text/template">## Installation

### PostgreSQL/PostGIS
<img src="assets/images/postgresql_postgis.png" width="300">


</script></section><section data-markdown><script type="text/template">

#### Sous Linux (Debian / Ubuntu)

- Ajouter le d√©pot dans source.list

```shell
sudo sh -c 'echo "deb https://apt.postgresql.org/pub/repos/\
apt nomdistribution-pgdg main" >> /etc/apt/sources.list'
```
- Ajouter la cl√©

```shell
wget --quiet -O - http://apt.postgresql.org/pub/\
repos/apt/ACCC4CF8.asc | sudo apt-key add -
sudo apt update
```

</script></section><section data-markdown><script type="text/template">

- Installer PostgreSQL 13, PGAdmin 4, PostGIS 3, PG Routing, SHP2PGSQL et RASTER2PGSQL :

```shell
# PostgreSQL 13
sudo apt install postgresql-13
# PostGIS 3
sudo apt install postgresql-13-postgis-3
# Pg Routing
sudo apt install postgresql-13-pgrouting
# SHP2PGSQL/RASTER2PGSQL
sudo apt-get install postgis-gui
```


</script></section><section data-markdown><script type="text/template">

##### D√©finir un mot de passe pour l'utilisateur postgres

- Lancer la commande psql avec l'utilisateur postgres
```psql
sudo su postgres -c "psql"
```
- Rentrer le mot de passe
```psql
\password postgres
```
- Fermer psql
```psql
\q
```

</script></section><section data-markdown><script type="text/template">

##### Sites utiles:

- Installation de [PgAdmin4](https://gist.github.com/Prototype-X/fd8bf6d8b929224621613316bf37db02)
- [Osgeo](https://trac.osgeo.org/postgis/wiki/UsersWikiPostGIS24UbuntuPGSQL10Apt)
- Le [wiki](https://wiki.postgresql.org/wiki/Apt) de Postgres

</script></section><section data-markdown><script type="text/template">


#### Sous Windows et MacOSX

- Un installeur pour Windows et MacOSX est fourni par une soci√©t√©
 partenaire : [EntrepriseDB](https://www.enterprisedb.com/downloads/postgres-postgresql-downloads).

- L'installeur ¬´¬†One Click¬†¬ª est librement t√©l√©chargeable. Apr√®s
 en avoir obtenu une copie, lancez-le. Le programme vous demandera
 successivement 5 informations :
  - les r√©pertoires d'installation et de donn√©es,
  - le mot de passe du super-utilisateur (par d√©faut utiliser postgres),
  - le port sur lequel √©couter,
  - la locale √† utiliser.

</script></section><section data-markdown><script type="text/template">

#### Sous Windows et MacOSX

- √Ä l'issue de l'installation, vous trouverez un nouveau
 sous-r√©pertoire dans vos programmes avec :
  - les clients pgAdmin4 et psql,
  - des boutons de contr√¥le du service PostgreSQL,
  - l'acc√®s √† la documentation,
  - StackBuilder.

- StackBuilder permet d'installer proprement des applications tierces,
 notamment PostGIS.

</script></section><section data-markdown><script type="text/template">

#### Sous Windows et MacOSX

- Sur les versions r√©centes de Windows et sur MacOSX, les probl√®mes de
 droits sont fr√©quents √† l'installation.

- Pour Mac, fa√Ætes l'installation avec le compte ¬´¬†root¬†¬ª.

- Sous Windows, cr√©ez de pr√©f√©rence un r√©pertoire de donn√©es en
 dehors de ¬´¬†Program Files¬†¬ª. Ex√©cutez l'installeur en tant
 qu'administrateur.

</script></section><section data-markdown><script type="text/template">

#### Sous Windows et MacOSX

- Pour installer PostGIS :
  - lancez StackBuilder,
  - s√©lectionnez le serveur local,
  - choisissez un miroir (n'importe lequel de ceux propos√©s devrait faire
 l'affaire),
  - dans la cat√©gorie ¬´¬†Extensions¬†¬ª, cochez PostGIS,
  - validez.

- Un nouveau sous-r√©pertoire appara√Æt dans vos programme pour l'acc√®s
 √† la documentation.

</script></section><section data-markdown><script type="text/template">

#### Sous Windows et MacOSX

![](assets/images/stack_builder.png)

</script></section><section data-markdown><script type="text/template">


#### Performances

- [__Optimiser PostgreSQL__](https://pgtune.leopard.in.ua) pour gagner en performances ==> ([__explication des valeurs__](https://community.jaguar-network.com/optimisation-dun-serveur-postgresql/))

- Param√©trage dans le fichier __postgresql.conf__
- Pour aller plus loin : [__gestion m√©moire avec PostgreSQL__](https://www.dalibo.org/glmf107_gestion_memoire_avec_postgresql)

</script></section><section data-markdown><script type="text/template">

### Pratique

#### Prise en main avec quelques requ√™tes simples

**Exercice 1 : Requ√™tes SQL**

- 1.1 Cr√©er une base de donn√©es vide formation
- 1.2 Restauration de la base de donn√©es formation
- 1.3 Requ√™tes simples
- 1.4 Jointures
- 1.5 Agr√©gations
- 1.6 Ordonnancement, limitation et pagination
- 1.7 Conditions
- 1.8 Calculs


</script></section></section><section ><section data-markdown><script type="text/template">## Installation

### Activer PostGIS

#### M√©thode d'installation

- PostGIS est une collection de types et fonctions qu'il faut charger
 dans la base de donn√©es.
- Depuis PostgreSQL 9.1 et PostGIS 2.0, il est possible de charger
 PostGIS comme extension¬†:
 ```sql
CREATE EXTENSION postgis;
```
- Cette m√©thode peut √™tre utilis√©e sur une base nouvelle ou
 existante.

- Cette commande, comme toute extension PostgreSQL, doit √™tre execut√©e par un "super user" (par d√©faut, postgres).

</script></section><section data-markdown><script type="text/template">
#### M√©thode d'installation

- Pour conna√Ætre la version de PostGIS install√©e sur le serveur PostgreSQL :
 ```sql
 SELECT PostGIS_full_version();
 ```
- Pour mettre √† jour PostGIS:
 ```sql
ALTER EXTENSION postgis UPDATE;
 ```
</script></section></section><section ><section data-markdown><script type="text/template">## Donn√©es spatiales



### Types de donn√©es

- PostGIS s'appuie principalement sur la g√©om√©trie, il permet
 d'associer une forme g√©o-localis√©e √† un enregistrement de la base de
 donn√©es.
 
</script></section><section data-markdown><script type="text/template">

### Types de donn√©es

- Ces formes peuvent √™tre¬†:
![](assets/images/formes_geometriques.png)


</script></section><section data-markdown><script type="text/template">

### Notation WKT

- Le ¬´¬†Well Known Text¬†¬ª est un langage de description, de la
 g√©om√©trie et de son syst√®me de coordonn√©es, d√©fini dans la sp√©cification Simple Feature de l'[OGC](http://www.opengeospatial.org/docs/is).
 
```
POINT(10 10)
MULTIPOINT(10 10,  20 20)
LINESTRING(10 10, 20 20, 30 40)
MULTILINESTRING((10 10, 20 20),
                (15 15, 30 15))
-- /!\\ double parenth√®ses
POLYGON((10 10, 10 20, 20 20, 20 15, 10 10))
MULTIPOLYGON(((10 10, 20 20, 20 15, 10 10)),
              ((60 60, 70 70, 80 60, 60 60)))
GEOMETRYCOLLECTION(POINT(10 10), POINT(30 30),
                   LINESTRING(15 15, 20 20))
```

</script></section><section data-markdown><script type="text/template">


### Notation WKB

Le ¬´¬†Well Known Binary¬ª en est la repr√©sentation binaire.
```
POINT(10 10)-> "010100000000000000000024400000000000002440"
```
- 01¬†: sens d'√©criture
- 01¬†: Point
- Puis deux fois la notation de "10" en 8-bytes ¬†:
 http://en.wikipedia.org/wiki/Double-precision_floating-point_format
 


 

</script></section><section data-markdown><script type="text/template">

### Syst√®me de coordonn√©es

- PostGIS stocke le syst√®me de coordonn√©es dans lequel une g√©om√©trie
 est d√©finie.
- L'information ¬´¬†syst√®me de coordonn√©es¬†¬ª est repr√©sent√©e par
 son code [EPSG](http://www.epsg-registry.org/) (cl√© primaire de la table spatial_ref_sys : __srid__).
- PostGIS ne fait __JAMAIS__ de reprojection implicite √† la vol√©e.
- Une op√©ration impliquant deux g√©om√©tries d√©crites dans des
 syst√®mes diff√©rents provoquera une erreur.

</script></section><section data-markdown><script type="text/template">


### Projections cartographiques

<img src="assets/images/projections.jpg" width="450">

</script></section><section data-markdown><script type="text/template">
A lire üëâ **Le scandale de Mercator** en bande dessin√©e
https://twitter.com/Artisans_Cartos/status/1260187936202645505

<table><tr>
<td> <img src="https://pbs.twimg.com/media/EX0UllgX0AELNJe?format=jpg&name=medium" alt="Le scandale de Mercator" style="width: 800px;"/> </td>
<td> <img src="https://pbs.twimg.com/media/EX0UxvvXYAAATbK?format=jpg&name=medium" alt="Le scandale de Mercator" style="width: 800px;"/> </td>
</tr></table>
</script></section><section data-markdown><script type="text/template">

### 2D, 3D, 4D

En plus des couples Est / Nord (ou latitude / longitude), PostGIS peut g√©rer (et
 indexer) deux dimensions suppl√©mentaires :
- __Z__ est l'√©l√©vation (__2.5D__).
- __M__ est une mesure associ√©e √† un point. Elle est utilis√© pour faire de l'interpolation lin√©aire et de la segmentation dynamique.
- Plusieurs cas de figure : __2D__, __3DZ__, __3DM__, __4D__.
- Certains fonctions disposent de variantes tenants compte de __Z__ ou de __M__.

</script></section><section data-markdown><script type="text/template">

### Manipulation de coordonn√©es g√©ographiques

- Par d√©faut, PostGIS fait ses calculs selon les principes de la
 g√©om√©trie plane (coordonn√©es cart√©siennes). Or il est tr√®s fr√©quent de manipuler des donn√©es en coordonn√©es g√©ographiques (long/lat)
 
- Dans ce cas, il est pr√©f√©rable de __choisir une projection adapt√©e__ √† la zone d'√©tude et de __transformer les coordonn√©es__ des objets. 

</script></section><section data-markdown><script type="text/template">

### Espace sph√©rique

- Si l'on souhaite faire des calculs de longues distances √† l'√©chelle mondiale, PostGIS a cr√©√© le type '__geography__' depuis sa version 1.5.

![](assets/images/orthodromie.jpg)

- Les approximations de distance sont alors plus pr√©cises (calcul en
 ¬´¬†grand cercle¬†¬ª), mais aussi plus co√ªteuses.
 
- Seules quelques fonctions disposent de variantes pour ce type.
 </script></section><section data-markdown><script type="text/template">
 Pour aller plus loin :
 
 - [WKT/WKB](https://www.gaia-gis.it/spatialite-3.0.0-BETA/spatialite-cookbook-fr/html/wkt-wkb.html)
 - [Coordonn√©es g√©ographiques](http://www.postgis.fr/chrome/site/docs/workshop-foss4g/doc/geography.html) 
 
</script></section></section><section ><section data-markdown><script type="text/template">## SQL basique

###  Manipulation des donn√©es avec PostGIS

<iframe src="https://giphy.com/embed/1463o17ejELYqs" width="200" height="200" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>

</script></section><section data-markdown><script type="text/template">

#### Diff√©rents types de fonctions

Outre le type 'geometry', PostGIS fournit de nombreuses fonctions spatiales. Ces fonctions sont d√©taill√©es dans la documentation en ligne.

- __Constructeurs__ : ST_MakePoint(), ST_GeomFromText(), ... 
- __Relations g√©om√©triques__ : ST_Distance(), ST_Within(),
 ST_Intersects(), ST_Overlaps(), ...
- __Traitements__ : ST_Centroid(), ST_Area(), ST_Buffer(), ...
- __Descriptions__ : ST_AsText(), ST_SRID(), ...

</script></section><section data-markdown><script type="text/template">

#### Constructeurs (1/2)

- La fonction __ST_GeomFromText()__ permet de cr√©er un objet de type
 geometry √† partir du __WKT__. On l'utilise pour d√©crire ¬´¬†√† la main¬†¬ª
 une g√©ometrie.
 ```
SELECT * FROM parcelle
WHERE the_geom = ST_GeomFromText('POLYGON(...)', 2154);
```
 
- Quelques fonctions utiles :

  - __ST_MakePoint(x, y)__‚Üí construit une g√©om√©trie √† partir de coordonn√©es x et y.
  - __ST_MakeBox2D(point, point)__ ‚Üí cr√©e une enveloppe spatiale d√©finie par le point inf√©rieur gauche et le point sup√©rieur droit.
  - __ST_MakeLine(set)__‚Üí prend une s√©quence de points et les encha√Æne pour former une ligne
  - __ST_Polygonize(set)__‚Üí cr√©e une geometrycollection constitu√© de potentiels polygones √† partir d'un ensemble de g√©om√©tries
  


</script></section><section data-markdown><script type="text/template">

#### Constructeurs (2/2)

- __CAST__ (coercition)¬†: force le type d'un objet

  op√©rateur chaine::type
  
  - Geometries (EWKT)
 
  ```
  SELECT 'SRID=4326;POINT(0,0)'::geometry
  ```

  - Emprises
 
  ```
  SELECT 'BOX(xmin ymin,xmax ymax)'::box2d
  ```

</script></section><section data-markdown><script type="text/template">



### V√©rification du syst√®me de coordonn√©es 

On peut conna√Ætre  le syst√®me de coordonn√©es (SRID) d'une g√©om√©trie :
```
SELECT ST_SRID(geometry) FROM ma_table LIMIT 1;
```
Il est possible de r√©cup√©rer sa d√©finition au format WKT / Proj4 (elle contient les __unit√©s__ utilis√©es):
```
SELECT srtext / proj4text FROM spatial_ref_sys
WHERE srid = 3857;
```
On peut transformer une g√©om√©trie dans un autre syst√®me de coordonn√©es :
- __ST_Transform(geom, srid)__

Si le syst√®me de coordonn√©es est ind√©fini, on peut le forcer (avec prudence - PostGIS ne fait aucune transformation de mani√®re implicite) :
- __ST_SetSRID(geom, srid)__

</script></section><section data-markdown><script type="text/template">

#### Relations g√©om√©triques (1/2)
Pour tester la relation g√©om√©trique liant deux objets, on peut
 utiliser des fonctions¬†:
 
- __ST_Equals(geomA, geomB)__

![](assets/images/equals.png)

</script></section><section data-markdown><script type="text/template">

- __ST_Disjoint(geomA, geomB)__

![](assets/images/disjoint.png)

</script></section><section data-markdown><script type="text/template">

- __ST_Intersects(geomA, geomB)__

![](assets/images/intersects.png)

</script></section><section data-markdown><script type="text/template">

- __ST_Crosses(geomA, geomB)__

![](assets/images/cross.png)

</script></section><section data-markdown><script type="text/template">

- __ST_Overlaps(geomA, geomB)__

![](assets/images/overlap.png)

</script></section><section data-markdown><script type="text/template">

- __ST_Touches(geomA, geomB)__

![](assets/images/touch.png)

</script></section><section data-markdown><script type="text/template">

- __ST_Within(geomA, geomB)__
- __ST_Contains(geomA, geomB)__

![](assets/images/within_contains.png)

</script></section><section data-markdown><script type="text/template">

- __ST_DWithin(geomA, geomB, dist)__

![](assets/images/dwithin.png)

Source¬†: [Postgis spatial relationships](http://postgis.fr/chrome/site/docs/workshop-foss4g/doc/spatial_relationships.html) 


Voir les exemples de ces relations [ici](http://www.postgis.org/docs/reference.html) 


</script></section><section data-markdown><script type="text/template">

#### Relations g√©om√©triques (2/2)


De m√™me, des op√©rateurs testent la relation g√©om√©trique entre les
bo√Ætes englobantes de deux objets¬†:
- __A = B__  ‚Üí A egal B
- __A && B__ ‚Üí A intersecte B
- __A ~ B__  ‚Üí A contient B
- __A @ B__  ‚Üí A est contenue par B
- __A<#>B__  ‚Üí distance between A and B


</script></section><section data-markdown><script type="text/template">

#### Diff√©rence entre && et St_Intersects 

Ces deux m√©thodes permettent de s√©lectionner des g√©om√©tries qui intersectent d'autres g√©om√©tries. 

- && utilise les bo√Ætes englobantes pour v√©rifier qu'elles s'intersectent. Cette m√©thode peut donc renvoyer plus d'entit√©s en raison des BBox qui se chevauchent. **Elle peut donc √™tre plus rapide que la fonction St_Intersects.**

Exemple : 
```
SELECT * FROM a, b WHERE a.geom && b.geom;
```
Cette requete renvoit tous les √©l√©ments de a et b dont les boites englobantes s'intersectent.

Source : [ST_Intersects and &&](https://geekswithlatitude.readme.io/docs/st_intersects)
</script></section><section data-markdown><script type="text/template">

- St_Intersects s√©lectionne avec pr√©cision toutes les g√©om√©tries qui s'intersectent. Elle commence par faire une premi√®re s√©lection avec les BBox puis elle r√©duit la liste des entit√©s √† celles dont les g√©om√©tries se croisent r√©ellement.

Exemple : 
```
SELECT * FROM a, b 
WHERE ST_INTERSECTS (a.geom,b.geom);
```
Cette requete renvoit d'abord tous les √©l√©ments de a et b dont les boites englobantes s'intersectent, puis r√©duira ensuite la liste des √©l√©ments √† ceux qui se coupent r√©ellement √† l'aide des g√©om√©tries.
![](assets/images/index_spatial.png)

Ici, qu'est ce qui renvoit ```TRUE``` au test d'intersection de l'√©toile?



</script></section><section data-markdown><script type="text/template">

#### Traitements
- __Aggr√©gation de g√©om√©tries__‚ÜíM√™me comportement que __COUNT__, __AVG__, __SUM__... 
- __ST_Buffer(geom, distance)__‚Üí Zone tampon
- __ST_Intersection(geomA, geomB)__‚ÜíPortion commune entre  A et B
- __ST_Difference(geomA, geomB)__‚ÜíPortion de A qui n'intersecte pas B
- __ST_Union(geomA, geomB)__‚ÜíUnion de deux g√©om√©trie sans les contours
- __ST_Line_Interpolate_Point()__‚ÜíPoint interpol√© sur la ligne
- __ST_ConvexHull()__‚ÜíPlus petite g√©om√©trie convexe qui englobe toutes les g√©om√©tries
- __ST_Collect(geometry)__‚Üí MULTI*
- __ST_Dump(geometry)__ ‚Üí Liste de g√©om√©tries


</script></section><section data-markdown><script type="text/template">

#### Transformations

- __ST_Scale(geom, Xcoef, Ycoef, Zcoef)__‚ÜíRetaille la g√©om√©trie
- __ST_Affine(geom, X, Y, Z)__‚ÜíTransformation affine (translation)
- __ST_Simplify(geom, tolerance)__‚ÜíSuppression de x noeuds
- __ST_SnapToGrid(...)__‚ÜíAccroche les points √† une grille
- __ST_LineMerge(geometry collection)__‚ÜíEnsemble de lignes contigues

</script></section><section data-markdown><script type="text/template">

#### Extraire des informations

- __ST_AsText(geom)__‚Üí WKT
- __ST_Dimension(geom)__ ‚Üí Point, Ligne, Polygone
- __ST_Centroid(geom)__‚Üí Barycentre
- __ST_Envelope(geom)__ ‚Üí BBOX
- __ST_GeometryType(geom)__‚Üí Type de g√©om√©trie
- __ST_X(point)__ et __ST_Y(point)__‚Üí Long,lat
- __ST_Area(geom)__‚Üí Surface
- __ST_Perimeter(geom)__‚Üí Longueur de tous les contours

</script></section><section data-markdown><script type="text/template">


#### Diff√©rences entre ST_ et pas ST_

- L'adoption par Postgis de la norme SQL/MM impose de nommer les fonctions ```ST_``` (*Spatial Type*) et de les s√©parer des autres fonctions.
- Les fonctions Postgis ne commen√ßant pas par ```ST_``` sont d√©pr√©ci√©es et amen√©es √† √™tre supprim√©es dans les versions ult√©rieures :
	‚Üí  ex : pour trouver le syst√®me de coordonn√©e d'une g√©om√©trie,  utiliser ```ST_SRID(geom)``` et non plus ```Find_SRID(geom)```
	
</script></section><section data-markdown><script type="text/template">	
	
### Pratique 

#### Prise en main de Postgis

**Exercice 2 : Op√©rations spatiales**

	- 2.1 Conna√Ætre le syst√®me de coordonn√©es et l'unit√© des g√©om√©tries
	- 2.2 Construire des g√©om√©tries ¬´ √† la vol√©e ¬ª
	- 2.3 Jointure spatiale
	- 2.4 Distances
	- 2.5 D√©tection des micro-polygones
	- 2.6 Agr√©ger des g√©om√©tries 
</script></section></section><section ><section data-markdown><script type="text/template">## Structure de PostgreSQL

### Hi√©rarchie des objets

* Les donn√©es de l'utilisateur sont organis√©es selon la hi√©rarchie : base de donn√©es, sch√©ma, table, colonne.
* Les tables et les colonnes permettent le stockage de donn√©es relationnelles.
* Les bases de donn√©es et les sch√©mas organisent les tables en groupes th√©matiques.

</script></section><section data-markdown><script type="text/template">

### Hi√©rarchie des objets

<img src="assets/images/postgresql_hierarchy.jpg" width="300">

</script></section><section data-markdown><script type="text/template">

### Hi√©rarchie des objets

- √Ä part la liste des `users` et `roles`, aucune donn√©e n'est partag√©e
 entre deux bases de donn√©es.
- Les tables supportent :
  - les contraintes (primary key, foreign key, check, unique, etc...),
  - les index, notamment de type GiST et btree.
- Les `functions`, `casts`, `operators`, `sequences` et `types` d√©finis par l'utilisateur sont stock√©s au niveau des sch√©mas.

</script></section><section data-markdown><script type="text/template">

### Notion de ¬´¬†catalog¬†¬ª

- Les objets cr√©√©s par les utilisateurs sont d√©crits dans... une base
 de donn√©es !
- Les tables de cette m√©ta-base sont appel√©es catalogs et sont
 pr√©fix√©es par ¬´¬†pg_*¬†¬ª.
- Les `catalogs` ne sont visibles que par les super-utilisateurs.
- Ne tentez pas de modifier ces tables¬†!


</script></section><section data-markdown><script type="text/template">

### Les ¬´¬†catalogs¬†¬ª PostGIS

- PostGIS n'utilise pas ou peu les catalogs pour publier ses propres
 m√©ta-donn√©es (fonctionnement impos√© par le standard OGC Simple
 Feature).
- Les colonnes PostGIS sont d√©crites dans les vues¬†:
  - `geometry_columns`
  - `geography_columns`
  - `raster_columns`
  - `raster_overviews`
- Les syst√®mes de coordonn√©es sont list√©s dans la table
 `spatial_ref_sys`.
 


</script></section></section><section ><section data-markdown><script type="text/template">## Structure de PostgreSQL


### Gestion des sch√©mas

</script></section><section data-markdown><script type="text/template">


#### Notion de ¬´¬†schema¬†¬ª

- Les ```schemas``` sont des √©l√©ments issus du monde Oracle.
- Utiles pour organiser les droits ou les donn√©es par  th√©matique.
- Pour √™tre ¬´¬†transparent¬†¬ª, un ```schema``` doit √™tre enregistr√© dans
 le ```search_path```.
- Les ```schemas``` ne font pas partie de la norme SQL et sont parfois mal reconnus par les applications clientes.
- Par d√©faut tout est dans le sch√©ma ```public```.

Pour lister toutes les tables du sch√©ma public:
```sql
SELECT table_name 
FROM information_schema.tables 
WHERE  table_schema='public';
```

</script></section><section data-markdown><script type="text/template">

#### Visibilit√© des sch√©mas

- Notion de variables¬†: ```SET nom = valeur```.
- On peut acc√©der aux sch√©mas non visibles en utilisant leur nom comme
 pr√©fixe.
- Pour un acc√®s ¬´¬†transparent¬†¬ª au sch√©ma, il faut jouer avec le
 ```search_path```¬†:
 
```sql
-- Pour la session courante ...
SHOW search_path;
SET search_path = topology, public;
RESET search_path ;

-- ... ou d√©finitivement 
ALTER USER martin SET search_path = topology, public;
```

</script></section><section data-markdown><script type="text/template">

#### Int√©r√™t d'utiliser des sch√©mas

 L'avantage de l'utilisation des sch√©mas par rapport √† l'utilisation de plusieurs bases est qu'**il est possible d'effectuer des requ√™tes impactant plusieurs sch√©mas d'une base, ce n'est pas le cas entre plusieurs bases**.


On peut voir un sch√©ma comme des ¬´ **sous-bases** ¬ª. Ces sous-bases ayant la possibilit√© d'√™tre poreuses, nous pouvons faire transiter ou pas des informations entre les sch√©mas. Chose que l'on ne peut pas faire entre les bases de donn√©es √† moins d'utiliser des programmes externes ou des connecteurs particuliers (comme *dblink*).</script></section></section><section ><section data-markdown><script type="text/template">## Organiser les donn√©es

### Introduction au mod√®le relationnel

![](assets/images/Etages.svg)

</script></section><section data-markdown><script type="text/template">

#### Mod√©lisation relationnelle

- Le mod√®le de donn√©es organise un ensemble d'__informations
 s√©mantiquement li√©es__.
- Chaque information peut prendre diverses __valeurs__. 
- L'ensemble des valeurs possibles pour une information est son
 __domaine__.
- Au niveau du SGBD, le domaine est d√©fini par le __type de donn√©es__ et
 les √©ventuelles __contraintes__.
- Toutes les informations directement d√©pendantes d'une cl√© primaire
 sont li√©es dans une __relation__.


</script></section><section data-markdown><script type="text/template">
#### Cardinalit√©

| CARDINALITE| SYMBOLE|DESCRIPTION|
|----------|:-------------:|------:|
|Un-Un|1.1|Une occurence de la 1√®re entit√© correspond √† une et une seule occurence de la 2de entit√©|
|Un-Plusieurs|1.n|Une occurrence de la 1√®re entit√© correspond √† plusieurs occurrences de la 2de entit√©|
|Plusieurs-Un|n.1|Plusieurs occurrences de la 1√®re entit√© correspondent √† la m√™me occurrence de la 2de entit√©|
|Plusieurs-Plusieurs|n.n|Plusieurs occurrences de la 1√®re entit√© correspondent √† plusieurs occurrences de la 2de entit√© |

</script></section><section data-markdown><script type="text/template">

La cardinalit√© indique le nombre d'occurences d'une entit√© par rapport √† une autre entit√©.
Une relation de type n-n devient une nouvelle table, appel√©e __table de correspondance__. 

</script></section><section data-markdown><script type="text/template">

#### Comment lire un mod√®le relationnel de donn√©es?

![](assets/images/Formateurs.svg)

</script></section><section data-markdown><script type="text/template">

- Un formateur peut dispenser **1 ou plusieurs** sessions==> *1.n*
- Une session peut √™tre dispens√©e **par 1 et 1 seul** formateur==>*1.1*
- Une formation concerne **1 ou plusieurs** sessions==>*1.n*
- Une session concerne **1 et 1 seule** formation==>*1.1*
- Une session peut avoir **1 ou plusieurs** stagaires==>*1.n*
- Un stagiaire peut assister √† **1 et 1 seule** session==>*1.1*
- Une formation peut √™tre organis√©e par  **1 ou plusieurs** agences Makina Corpus==>*1.n*
- Une agence Makina Corpus peut organiser √† **0 ou plusieurs** formations==>*0.n*

</script></section><section data-markdown><script type="text/template">
#### Logiciels d'aide √† la conception 

Il existe plusieurs logiciels d'aide √† la conception de bases de donn√©es relationnelles.

- [AnalyseSI](http://www.analysesi.com/), fourni au format d'archive (java).
- [Mocodo](http://www.mocodo.net/), site interactif. 

Ils dessinent le mod√®le conceptuel de donn√©es (MCD) et g√©n√®rent le sch√©ma relationnel (MLD : mod√®le logique de donn√©es) pour PostgreSQL. 



</script></section><section data-markdown><script type="text/template">

#### Mod√©lisation relationnelle

- Le mod√®le relationnel explique comment organiser l'information en
 s'appuyant sur les __relations s√©mantiques__.
- Le mod√®le relationnel offre donc une base de travail pour la gestion
 de l'information.
- Toutefois, si une information est __redondante__, la __coh√©rence__ de
 l'information ne peut √™tre garantie.
- La normalisation du mod√®le r√©soud ce probl√®me en imposant des
 __formes normales__ au concepteur.

</script></section><section data-markdown><script type="text/template">

#### Formes normales

**Objectif** : permettre la __d√©composition en relations sans perdre de l'information__.

**Avantages** : 
* limiter les redondances de donn√©es (multiples √©critures) ;
* diminuer la volum√©trie globale, ce qui r√©duit l'espace disque n√©cessaire, mais plus encore la taille du cache - les SGBDR travaillant en m√©moire ;
* interdire les incoh√©rences de donn√©es venant des redondances dont une partie seulement a √©t√© mise √† jour, ce qui rendrait de fait les donn√©es inutilisables (diff√©rentes versions d'une m√™me information, sans que l'on sache laquelle est valide) ;
* limiter grandement le nombre et la dur√©e des mises √† jour qui sont des processus bloquants (√©critures).


</script></section><section data-markdown><script type="text/template">

<img src="assets/images/formesnormales.png" width="500">

*Source* : Introduction pratique aux bases de donneÃÅes relationnelles (2eÃÄ ed, 2006) - [Springer] - A. Meier


</script></section><section data-markdown><script type="text/template">

#### Formes normales
##### 1NF

*¬´¬†Dans un mod√®le en 1√®re forme normale, aucun attribut n'est
 multi-valu√©¬†¬ª.*
 
Il s'agit de v√©rifier qu'il n'y a jamais plusieurs valeurs stock√©es
 pour une information.
 
- Exemple¬†: une personne peut avoir un ou plusieurs pr√©noms. On pourra
 d√©cider :
  - d'avoir trois colonnes,
  - de cr√©er une table reli√©e par une cl√© externe,
  - de ne garder que le pr√©nom principal.
  
  </script></section><section data-markdown><script type="text/template">
 Exemple de table non normalis√©e
 
 ```sql
 personne(#nom, profession) 
 ```

|nom| profession | 
|----------|:-------------:
|Martin|G√©omaticien|
|Dupont|D√©veloppeur-Graphiste|

La relation **personne** n'est pas en 1ere forme normale, car l'attribut `profession` peut contenir plusieurs valeurs.

</script></section><section data-markdown><script type="text/template">

 Exemple de table en 1√®re forme normale :
 
On ajoute `profession` √† la cl√© pour faire appara√Ætre deux tuples √† Dupont.

personne(#nom, #profession) 

|nom| profession | 
|----------|:-------------:
|Cohen|G√©omaticien|
|Dupont|D√©veloppeur web|
|Dupont|Graphiste|

</script></section><section data-markdown><script type="text/template">

...ou alors on ajoute un attribut `professionsecondaire`

personne(#nom, profession, professionsecondaire) 

|nom| profession|profession secondaire|
|----------|:-------------:|:-------------:
|Cohen|G√©omaticien|Null|
|Dupont|D√©veloppeur web|Graphiste|


</script></section><section data-markdown><script type="text/template">

##### 2NF

 *Une relation est en 2eme forme normale si elle est en 1ere forme normale.*
 
¬´¬†Dans un mod√®le en 2√®me forme normale, tout attribut hors de
 la cl√© primaire ne d√©pend pas d'une sous-partie seulement de la cl√©¬†¬ª
 
 La deuxi√®me forme normale permet d'√©liminer les d√©pendances entre des parties de cl√© et des attributs n'appartenant pas √† une cl√©.
 
 </script></section><section data-markdown><script type="text/template">
- Exemple¬†:

```sql
personne(#numeroemploye, #profession, nom, prenom, salaire) 
```
|numeroemploye|profession|nom|prenom|salaire| 
|----------|:-------------:|:-------------:|:-------------:| :-------------:
|1|G√©omaticien|Cohen|H√©l√®ne|2000|
|2|D√©veloppeur web|Dupont|Andr√©|2250|
|3|Comptable|Michel|Vincent|2200|
|4|Charg√© de communication|Robert|Marcel|2200|
|5|Chef de projet|Charpentier|Elodie|2300|


La relation **personne** n'est pas en 2√®me forme normale car `profession` (une partie de cl√©) d√©termine salaire (un attribut qui n'appartient pas √† une cl√©)

</script></section><section data-markdown><script type="text/template">
C'est `profession` qui d√©termine `salaire`, il faut donc d√©composer `profession` en deux relations.

```sql
personne(#numeroemploye,#profession=>profession,nom,prenom) 
profession(#profession, salaire)
```

**personne**

|numeroemploye|profession|nom|prenom|
|----------|:-------------:|:-------------:|:-------------:|
|1|G√©omaticien|Cohen|H√©l√®ne|
|2|D√©veloppeur web|Dupont|Andr√©|
|3|Comptable|Michel|Vincent|
|4|Charg√© de communication|Robert|Marcel|
|5|Responsable ressources humaines|Charpentier|Elodie|

</script></section><section data-markdown><script type="text/template">

**profession**

|profession|salaire| 
|----------|:-------------:|
|G√©omaticien|2000|
|D√©veloppeur web|2250|
|Comptable|2100|
|Charg√© de communication|2200|
|Responsable ressources humaines|2300|

Ainsi `salaire` d√©pend d'une cl√© (`profession`) et non plus d'une partie de cl√©.


</script></section><section data-markdown><script type="text/template">

##### 3NF
*Une relation est en 3√®me forme normale si elle est en 2√®me forme normale.*

¬´¬†Dans un mod√®le en 3√®me forme normale,  tout attribut n‚Äôappartenant pas √† une cl√© ne d√©pend pas d‚Äôun autre attribut non cl√©.¬†¬ª

La troisi√®me forme normale permet d'√©liminer les d√©pendances entre les attributs n'appartenant pas √† une cl√©.
 </script></section><section data-markdown><script type="text/template">
 
 - Exemple¬†:

```sql 
profession(#profession, salaire, diplome) 
```
n'est pas en 3√®me forme normale.

|profession|salaire|diplome| 
|:-------------:|:-------------:|:-------------:|
|G√©omaticien|2000|SIG|
|D√©veloppeur web|2250|Technologies web|
|Comptable|2100|Comptabilit√© et de Gestion|
|Charg√© de communication|2200|Information et Communication|
|Responsable ressources humaines|2300|Gestion des Ressources humaines|


</script></section><section data-markdown><script type="text/template">

L'attribut `salaire`, qui n'est pas une cl√© d√©termine `diplome`. Pour √™tre en 3√®me forme normale il faut d√©composer la table **profession**.

```sql
profession(#profession, salaire=>salaire)
salaire(#salaire, diplome)
```
**profession**

|profession|salaire|
|:-------------:|:-------------:|
|G√©omaticien|2000|
|D√©veloppeur|2250|
|Comptable|2100|
|Charg√© de communication|2200|
|Responsable ressources humaines|2300|

</script></section><section data-markdown><script type="text/template">

**salaire**

|salaire|diplome| 
|:-------------:|:-------------:|
|2000|SIG|
|2250|Technologies web|
|2100|Comptabilit√© et de Gestion|
|2200|Information et communication|
|2300|Gestion des Ressources humaines|


</script></section><section data-markdown><script type="text/template">

#### Choix d'impl√©mentation

- Dans la r√©alit√© et pour des soucis de simplification un sch√©ma n'est __jamais en forme normale__...

- Cela n'emp√™che pas de v√©rifier la coh√©rence avec des contraintes
 comme ```UNIQUE``` et/ou ```NOT NULL```.
 
- Lorsqu'une jointure est tr√®s fr√©quente, on s'autorisera parfois √†
 la stocker dans une table.
 
- Les donn√©es calcul√©es peuvent √™tre stock√©es.

Pour aller plus loin : [Wikipedia](https://fr.wikipedia.org/wiki/Forme_normale_%28bases_de_donn%C3%A9es_relationnelles%29)

</script></section><section data-markdown><script type="text/template">

#### Compromis entre normalisation et d√©normalisation?

- On normalise en g√©n√©ral par **souci d'√©conomie d'espace**, pour **√©viter de dupliquer** les donn√©es et pour **faciliter la maintenance** de la base de donn√©es.
- La normalisation **peut aussi entrainer des temps d'acc√®s plus longs si les requetes sont trop complexes**. 
- La d√©normalisation introduit une **redondance des donn√©es** au sien de plusieurs tables **afin de simplifier et optimiser** le traitement des requetes ou pour ajuster les donn√©es √† la demande de l'utilisateur.
- **D√©normaliser permet d'√©viter des calculs longs et fastidieux.**
</script></section><section data-markdown><script type="text/template">

|Cas d'utilisation|Conseil|
|:-------------:|:-------------:|
|Peu de lecture, peu de modifications|Pas besoin de d√©normaliser|
|Peu de lecture, beaucoup de modifications|Normaliser|
|Beaucoup de lecture, beaucoup de modifications|D√©normaliser va d√©grader les performances du serveur|
|Beaucoup de lecture, peu de modifications|D√©normaliser sera le meilleur choix|

</script></section></section><section ><section data-markdown><script type="text/template">## Organiser les donn√©es

### D√©finition des donn√©es

</script></section><section data-markdown><script type="text/template">

#### Cr√©ation d'une table

- En premier lieu, cr√©er une table consiste √† cr√©er une liste de
 colonnes.

- Chaque colonne est constitu√©e d'un nom, d'un type et √©ventuellement
 d'options :
  - ```DEFAULT valeur```
  - contrainte de colonne (```UNIQUE```, ```NOT NULL```...)

- Cette liste de colonnes est √©ventuellement compl√©t√©e par une liste
 de contraintes de table.

- On peut cr√©er la table avec le statut ```TEMPORARY```.

</script></section><section data-markdown><script type="text/template">

#### D√©finition des contraintes

- Contrainte de cl√© primaire : ```UNIQUE``` __et__ ```NOT NULL```.
 Elle peut √™tre multiple (porter sur une ou plusieurs colonnes).

- La contrainte de cl√© √©trang√®re assure l'int√©grit√© des tables d'une base de donn√©es. Elle peut √™tre multiple et poss√©der des
 options :

```sql
FOREIGN KEY insee REFERENCES commune ( insee )
ON DELETE SET NULL ON UPDATE CASCADE
```

- La contrainte CHECK permet d'exprimer une assertion. Sa condition doit
 toujours √™tre vraie :

```sql
CHECK ( age > 0 AND char_length(nom) > 2 )
```

</script></section><section data-markdown><script type="text/template">

#### Choix de la cl√©

- De nombreuses applications tierces exigent une cl√© primaire de type
 ```integer``` (QGis par exemple).
- Le type ```serial``` permet de cr√©er un entier auto-incr√©ment√©. Il s'agit
 en fait de la combinaison du type ```integer``` et d'une simple s√©quence.
```sql
CREATE TABLE my_table(
   id SERIAL PRIMARY KEY,
   name VARCHAR NOT NULL
);
```

</script></section><section data-markdown><script type="text/template">

#### Types de donn√©es standards

- Les __principaux__ [types de donn√©es PostgreSQL](https://docs.postgresql.fr/13/datatype.html) sont :
  - num√©riques : entiers, flottants, ¬´¬†serial¬†¬ª
  - cha√Ænes de caract√®res
  - texte
  - bool√©ens
  - √©num√©rations
  - dates, horaires
- Chaque type dispose d'un panel de fonctions et d'op√©rateurs
 permettant de le manipuler.

- Il est possible de cr√©er ses propres types.

Pour en savoir plus : [Les types num√©riques ](https://www.sqlfacile.com/apprendre_bases_de_donnees/les_types_sql_numeriques)

</script></section><section data-markdown><script type="text/template">

#### Types de donn√©es ++

Des types plus √©labor√©s sont d√©finis dans PostgreSQL :
- Intervalle (```daterange```, ```int8range```)
- Liste ou tableau (```int[]```)
- Adresse MAC (```macaddr```)

Des modules externes permettent de supporter des types additionnels :
- Universally Unique Identifiers (UUID) avec le module ```uuid-ossp```
- Cl√©-valeur avec le module ```hstore```
- ‚Ä¶


</script></section><section data-markdown><script type="text/template">


### Pratique

#### Structuration des donn√©es

**Exercice 3 : Structuration de donn√©es**

- 3.1 D√©finition de donn√©es attributaires

</script></section></section><section ><section data-markdown><script type="text/template">## SQL avanc√©

### Manipulation des donn√©es

</script></section><section data-markdown><script type="text/template">

#### Manipulation des donn√©es

- ```UPDATE``` et ```DELETE``` supportent tous les deux la clause ```WHERE``` pour d√©finir
 des conditions complexes et faire des jointures. Ceci afin de
 s√©lectionner les enregistrements √† mettre √† jour ou supprimer.

- On peut donc s√©lectionner un ensemble particulier de donn√©es comme
 avec une requ√™te ```SELECT``` et modifier cet ensemble gr√¢ce √† ```UPDATE``` ou le
 d√©truire gr√¢ce √† ```DELETE```.

- La commande ```TRUNCATE``` est un raccourci pour vider une table. Elle
 op√®re plus rapidement que ```DELETE```.

 ```sql
 TRUNCATE TABLE my_table;
 ```

</script></section><section data-markdown><script type="text/template">

#### Requ√™tes de modification

- La commande ```UPDATE``` modifie des donn√©es. Dans sa forme la plus simple,
 une telle requ√™te est :

```sql
UPDATE table SET column = value; -- modifie tout !
```
- Il est possible d'utiliser une clause ```WHERE``` pour ne modifier que les lignes validant une condition :

```sql
UPDATE parcelle SET surface_cadastrale = ST_Area(the_geom)
WHERE id_parcelle = 357;
```
- Enfin, si la condition requiert une jointure, on peut utiliser la
 clause FROM :

```sql
UPDATE parcelle p SET insee = s.insee
FROM section s
WHERE p.id_section = s.id_section ;
```

</script></section><section data-markdown><script type="text/template">

#### Requ√™tes de suppression

- On d√©truit des donn√©es avec ```DELETE```. Dans sa forme la plus simple, une
 telle requ√™te est :

```sql
DELETE FROM table; -- supprime toutes les lignes !
```
- Il est possible d'utiliser une clause ```WHERE``` pour ne supprimer que les lignes validant une condition :

```sql
DELETE FROM parcelle
WHERE ST_Area(the_geom) > 1000
```
- Enfin, si la condition requiert une jointure, on peut utiliser la
 clause ```USING``` :

```sql
DELETE FROM parcelle p
USING commune c
WHERE c.insee = p.insee AND c.nom ILIKE  'paris' ;
```

</script></section><section data-markdown><script type="text/template">

##### Diff√©rences entre TRUNCATE et DELETE

|POSSIBILIT√âS |DELETE|TRUNCATE|
|----------|----------|:-------------:|
|Restauration|Possible avec un COMMIT ou ROLLBACK|Pas de ROLLBACK possible|
|WHERE|Possible|Pas de clause WHERE|
|Rapidit√©|Moins rapide|Plus rapide|
|Cl√© primaire autoincr√©ment√©e|Garde le compteur en cours|Remet le compteur √† z√©ro|
|Journal des transactions|Enregistre les donn√©es de chaque ligne supprim√©e|N'enregistre pas les logs|
|Langage|Langage de Manipulation de Donn√©es (LMD)|Langage de D√©finition de Donn√©es (LDD)|


</script></section><section data-markdown><script type="text/template">
### Pratique

#### Structuration des donn√©es

**Exercice 3 : Structuration de donn√©es**

- 3.2 Mise √† jour de donn√©es attributaires
</script></section></section><section ><section data-markdown><script type="text/template">## Organiser les donn√©es

### D√©finition des donn√©es spatiales

</script></section><section data-markdown><script type="text/template">

#### Colonne g√©om√©trique

- Le type ```geometry``` re√ßoit 2 param√®tres¬†:
  - le type g√©om√©trique¬†: ```point```, ```linestring``` ou ```polygon``` avec
 optionnellement le pr√©fixe ```multi``` et les suffixes ```z``` ou ```m```,
  - l'identifiant du syst√®me de coordonn√©es.

```sql
ALTER TABLE parcelle
  ADD geom geometry(Polygon, 2154)¬†;
```
```sql
ALTER TABLE parcelle
  ADD geom geometry(MultiPolygonZM, 2154)¬†;
```

</script></section><section data-markdown><script type="text/template">

#### Ancienne m√©thode

- Avant PostGIS 2.0, il fallait utiliser une fonction pour cr√©er des
 colonnes g√©om√©triques¬†:

```sql
SELECT AddGeometryColumn('table_name', 'att_name', srid, 'GEOM TYPE',
 dim);
```
- En plus de cr√©er la colonne, cette fonction renseigne la m√©ta-table
 `geometry_columns`¬† et cr√©e les contraintes d'int√©grit√©
 n√©cessaires.

- De m√™me, pour supprimer une colonne :

```sql
SELECT DropGeometryTable('table_name');
SELECT DropGeometryColumn('table_name', 'col_name');
```
</script></section><section data-markdown><script type="text/template">

### Pratique

#### Structuration des donn√©es

**Exercice 3 : Structuration de donn√©es**

- 3.3 D√©finition de donn√©es g√©om√©triques
</script></section></section><section ><section data-markdown><script type="text/template">## SQL avanc√©

### Stocker une requ√™te

</script></section><section data-markdown><script type="text/template">

#### Que stocker¬†?

- On peut stocker soit la d√©finition de la requ√™te, soit son
 r√©sultat, soit les deux (√† partir de Postgresql 9.3).

- Les ¬´¬†vues¬†¬ª sont des requ√™tes enregistr√©es. Elles se comportent
 comme des tables (en lecture seule). Il en existe 2 types :

 	- les **vues**. Elles s'actualisent automatiquement √† chaque UPDATE, INSERT ou DELETE. La requ√™te sous-jacente est
 ex√©cut√©e √† chaque lecture.
 	- les **vues mat√©rialis√©es** (repr√©sentation d'une requete sous la forme d'une table).
 	Le r√©sultat est stock√© et raffraichi √† la demande.

- Une table peut √™tre cr√©√©e ou simplement remplie √† partir du
 r√©sultat d'une requ√™te.

</script></section><section data-markdown><script type="text/template">

#### Vues

- Cr√©er une vue consiste simplement √† donner un nom √† une requ√™te :

```sql
CREATE VIEW <name> AS <requete>;
```

- Pensez √† renommer proprement vos colonnes avec des ```AS``` dans la clause
 ```SELECT```.

</script></section><section data-markdown><script type="text/template">

#### Vues mat√©rialis√©es

- Cr√©er une vue mat√©rialis√©e :
```sql
CREATE MATERIALIZED VIEW <name> AS <requete>;
```

- Mettre √† jour cette vue :
```sql
REFRESH MATERIALIZED VIEW <name>;
```
Une t√¢che de fond peut √™tre planifi√©e pour mettre √† jour le r√©sultat de la vue en utilisant cette requ√™te SQL (chaque nuit par exemple).

</script></section><section data-markdown><script type="text/template">

#### Vues : modification ou suppression

- Pour modifier une vue, il suffit de remplacer `CREATE` par `CREATE OR REPLACE`.

```sql
CREATE OR REPLACE VIEW <name> AS <requete>;
```

- Pour supprimer une vue :

```sql
DROP VIEW <name>;
```

</script></section><section data-markdown><script type="text/template">

#### Vues : import dans QGis

- Aller dans l'onglet *Couche* > *Gestionnaire de sources de donn√©es* (Ctrl + L)

<img src="assets/images/qgis_view.png" width="400">

Attention, pour visualiser une vue avec QGis, il est imp√©ratif que celle-ci poss√®de une **cl√© primaire**.

</script></section><section data-markdown><script type="text/template">
### Pour aller plus loin

* sur [les vues](http://www.i3s.unice.fr/~rueher/Cours/BD/DocPostgresSQL9-5_HTML/rules-views.html)
* sur [les vues mat√©rialis√©es](http://www.i3s.unice.fr/~rueher/Cours/BD/DocPostgresSQL9-5_HTML/rules-materializedviews.html)

</script></section><section data-markdown><script type="text/template">

#### Stockage comme table

- Pour cr√©er une table √† partir du r√©sultat d'une requ√™te :
```sql
CREATE TABLE <name> AS <requete>;
```

- Cela ressemble beaucoup aux vues sauf que la requ√™te n'est calcul√©e
 qu'une fois pour remplir la table.
- Si la table existe d√©j√† :
```sql
INSERT INTO <name> (col1, col2, ...) <requete>;
```
- Dupliquer des donn√©es n'est g√©n√©ralement pas une bonne id√©e, sauf
 dans une table temporaire.

</script></section><section data-markdown><script type="text/template">
#### Les colonnes g√©n√©r√©es stock√©es
PostgreSQL 12 a introduit les colonnes calcul√©es:

- fonctionne comme une vue mais pour des colonnes
- le calcul des valeurs d'une colonne est r√©alis√© √† partir du contenu d'autres colonnes de la m√™me table
- la valeur calcul√©e est stock√©e sur disque.

</script></section><section data-markdown><script type="text/template">
###### Je cr√©e une table rectangle
```sql
CREATE TABLE rectangle
(
longueur real,
 largeur real,
 surface real GENERATED ALWAYS AS (longueur*largeur) STORED
);

```
###### J'ajoute des valeurs
```sql
INSERT INTO rectangle (longueur, largeur) VALUES (10, 20);
```

###### Je v√©rifie que les valeurs ont bien √©t√© calcul√©es pour `surface`

```sql
SELECT * FROM rectangle;
```

|longueur| largeur | surface
|----------|:-------------:|:-------------:|
|10|20 |200|


</script></section><section data-markdown><script type="text/template">
### Pratique

#### Affichage de requ√™tes dans QGIS

**Exercice 3 : Structuration de donn√©es**

- 3.4 Cr√©er et afficher des vues dans QGIS




</script></section></section><section ><section data-markdown><script type="text/template">## SQL avanc√©

### Optimisation des requ√™tes

<iframe src="https://giphy.com/embed/l1KtYs7ZpeBskCQus" width="480" height="208" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>

</script></section><section data-markdown><script type="text/template">

#### Index

- Un index est une structure de donn√©es annexe construite pour
 faciliter l'acc√®s aux donn√©es.

- On choisit de construire un index pour acc√©l√©rer un certain type de
 requ√™te bien identifi√©e. Lorsqu'une requ√™te est r√©currente, on cr√©e
 un index sur le crit√®re de recherche.

- L'acc√®s par index est g√©n√©ralement en temps constant alors que
 l'acc√®s direct √† la table est en temps lin√©aire.

</script></section><section data-markdown><script type="text/template">

##### Cr√©ation d'index

- On peut construire un index sur une simple colonne, sur un ensemble de
 colonnes ou sur une expression :

```sql
CREATE INDEX my_index
    ON my_table (Column1, Column2, ..);
```

- Les index ```B-tree``` sont destin√©s aux types scalaires (nombre ou chaine de caract√®res). Les ```GiST``` et ```GIN```
 permettent de cr√©er des index personnalis√©s.

- Par d√©faut, la commande ```CREATE INDEX``` va cr√©er un index B-tree.

- Des index sont cr√©√©s implicitement pour les cl√©s primaires et les cl√©s √©trang√®res.

</script></section><section data-markdown><script type="text/template">

##### Cr√©ation d'index

Un index peut √™tre vu comme un annuaire t√©l√©phonique :

```sql
CREATE INDEX idx_annuaire
    ON adresses (departement, ville, nom, prenom);
```

qui est diff√©rent de :

```sql
CREATE INDEX idx_annuaire_nom
    ON adresses (departement, nom, prenom, ville);
```

dans lequel vous devriez commencer par rechercher le nom et le pr√©nom de la personne
puis filtrer les doublons par ville.

</script></section><section data-markdown><script type="text/template">

* Pour le moteur SQL ce n'est pas la m√™me chose. Si vous lui demandez de lister toutes les personnes de la ville NANTES ayant le nom DURAND, il va utiliser `idx_annuaire`, filtrer sur la ville NANTES, puis sur le nom DURAND, ignorer le pr√©nom et sortir l'ensemble des lignes communes √† cette ville et ce pr√©nom. Il lui est impossible d'utiliser `idx_annuaire_nom` pour cette t√¢che.
* Et, si vous lui demandez toutes les personnes dont le pr√©nom est Pierre, il n'utilisera ni `idx_annuaire` ni `idx_annuaire_nom`. Aucun de ces deux index ne lui permet de commencer par filtrer sur les pr√©noms.

</script></section><section data-markdown><script type="text/template">

##### Cr√©ation d'index

**A retenir** :
* Un index sur **(col1, col2, col3)** rend inutile un index sur **(col1, col2)** et un index sur **(col1)**.
*Je n'ai pas besoin d'un deuxi√®me annuaire contenant l'ensemble des num√©ros de t√©l√©phone du d√©partement par ville, je l'ai d√©j√† avec l'annuaire de l'ensemble des num√©ros des d√©partement, par ville, nom et pr√©nom.*
* Un index sur **(col1, col2)** est diff√©rent d'un index sur **(col2, col1)**.

</script></section><section data-markdown><script type="text/template">

##### Les principaux types d'index

|Index|Utilisation| Type de donn√©es
|----------|:-------------:|:-------------:|
|B-tree¬†|¬†Pour des comparaisons : <, <=, =, >=, >, ```BETWEEN```, ```IN```|Chiffres, lettres, dates
|R-tree¬†|Divise les donn√©es en rectangles, et sous-rectangles, et sous-sous-rectangles, etc¬†|Types de donn√©es geospatiales en deux dimensions
|Hash|¬†Comparaison avec =|Chiffres, lettres, dates
|GiN|¬†Recherche en full text|¬†Types JSONB et tableaux|
|GiST|¬†Impl√©mentation du R-tree mais plus robuste|Donn√©es g√©ospatiales et la recherche en full text|

```sql
CREATE INDEX name ON table USING btree(att1, att2);
```

</script></section><section data-markdown><script type="text/template">

##### Index spatiaux

- Les index g√©om√©triques de PostGIS sont bas√©s par d√©faut sur GIST (*Generalized Search Tree*).

- Dans le cas des donn√©es spatiales, seules les emprises (bounding box) sont index√©es.

- Typiquement, un client cartographique utilisera l'index de cl√© primaire quand il acc√®de aux attributs d'un objet particulier et l'index g√©ographique pour retrouver les objets compris dans la zone d'affichage (l'emprise affich√©e).

 ![](assets/images/index_spatial.png)

 Source : [Workshop Foss4G](http://postgis.fr/chrome/site/docs/workshop-foss4g/doc/indexing.html)

</script></section><section data-markdown><script type="text/template">

##### Index spatiaux

- Essentiels pour les jointures spatiales¬†!

La plupart des fonctions utilis√©es par PostGIS (`ST_Contains`, `ST_Intersects`, `ST_DWithin`, etc)
prennent en compte les index automatiquement (s'ils existent dans le champ de geometrie).

- Cr√©ation d'un index spatial :

```sql
CREATE INDEX nom_table_gist
ON nom_table USING GIST (geom)
```
 </script></section><section data-markdown><script type="text/template">
##### Index spatiaux

 Voici la requ√™te pour lister l'ensemble des index du sch√©ma public :

```sql
SELECT
    tablename,
    indexname,
    indexdef
FROM
    pg_indexes
WHERE
    schemaname = 'public'
ORDER BY
    tablename,
    indexname;
```

 </script></section><section data-markdown><script type="text/template">
#### Optimisation : d√©tecter les requ√™tes co√ªteuses

Le premier outil √† disposition est le log des requ√™tes lentes.
Il faut √©diter le fichier `postgresql.conf`, rechercher cette ligne:
```
#log_min_duration_statement = -1
```
et la remplacer par
```
log_min_duration_statement = 2000
```
Ce qui indique de loger les requ√™tes qui mettent plus de deux secondes √† s'ex√©cuter.
Ce sera une bonne piste de d√©part.

Deux modules compl√©mentaires peuvent s'av√©rer utiles [auto_explain](https://www.postgresql.org/docs/9.5/auto-explain.html) et [pg_stat_statements](https://www.postgresql.org/docs/9.5/pgstatstatements.html).

</script></section><section data-markdown><script type="text/template">
La sortie de l'optimiseur obtenue √† l'aide de l'instruction __EXPLAIN ANALYZE__ est un bon moyen de comprendre comment Postgres ex√©cute les requ√™tes.

```sql
EXPLAIN ANALYZE SELECT *
FROM parcelle
WHERE ST_Within(geom, ST_Transform(St_GeomFromText
('POLYGON((2.232 48.818, 2.246 48.82, 2.241 48.809, 2.232 48.818))'
, 4326), 27572))
;
```
</script></section><section data-markdown><script type="text/template">
- Plan de requ√™te

 ![](assets/images/query_plan.png)
 </script></section><section data-markdown><script type="text/template">
Afin de rendre la sortie texte du QUERY PLAN plus explicite, il existe des services web qui permettent de copier/coller ces sorties et qui les transforment en sch√©mas graphiques.

- En voici quelques un :
	- https://explain.depesz.com/
	- https://explain.dalibo.com/

 </script></section><section data-markdown><script type="text/template">
 ![](assets/images/explaindalibo.png)

</script></section><section data-markdown><script type="text/template">
#### Optimisation : contr√¥ler l'usage r√©el des index

Le catalogue fournit deux vues qu'on ne manquera pas de consulter:
* `pg_stat_user_indexes` : si certains index ne sont jamais utilis√©s, doit-on les garder ?
* `pg_stat_user_tables` : si certaines tables sont trop scann√©es (voir leur `seq_scan`), il leur manque sans doute des index.

Les index sont utiles pour **am√©liorer la vitesse d'ex√©cution des requ√™tes** mais ils ont un **co√ªt non n√©gligeable en terme d'espace disque** (et de temps d'insertion/modification). Il est important de supprimer ceux qui ne sont pas utilis√©s.

  </script></section><section data-markdown><script type="text/template">
#### Optimisation : g√©rer le cache

- [Pr√©sentation du `shared_buffer`](https://easyteam.fr/postgresql-tout-savoir-sur-le-shared_buffer/)
- [Aller plus loin](https://madusudanan.com/blog/understanding-postgres-caching-in-depth/)

</script></section><section data-markdown><script type="text/template">
### Pratique

#### Optimisation des requ√™tes

**Exercice 3 : Structuration de donn√©es**

- 3.5 Index g√©om√©triques
</script></section></section><section ><section data-markdown><script type="text/template">## SQL avanc√©

### Entretien de la base de donn√©es
<iframe src="https://giphy.com/embed/RNDdIRbOM7hKH9ezKz" width="480" height="204" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>

</script></section><section data-markdown><script type="text/template">

#### VACUUM

- Le stockage des donn√©es sur disque est pagin√©. Apr√®s de nombreux
 ```INSERT```/ ``` DELETE```, les pages ne sont plus contigu√´s et l'acc√®s est moins
 efficace.
- ```VACUUM``` est l'op√©ration qui remet de l'ordre dans le stockage
 physique.
- L'option ```ANALYZE``` met en m√™me temps √† jour les statistiques de
 __l'optimiseur__ de requ√™tes.
</script></section><section data-markdown><script type="text/template">
- Analyser l'indexation
  - VACUUM¬†: r√©cup√®re l'espace inutilis√© issu de la suppression
 d'enregistrements
  - ANALYZE¬†: statistiques pour l'optimiseur de requ√™tes PostGreSQL

On peut r√©aliser les deux dans la m√™me commande:

```sql
VACUUM ANALYZE VERBOSE parcelle;
```

ou depuis la version 11.5 de PostgreSQL :

```sql
VACUUM VERBOSE ANALYZE parcelle;
```

</script></section><section data-markdown><script type="text/template">




#### D√©connecter une base de donn√©es

Il se peut que l'on ait besoin de forcer la d√©connection d'une base de donn√©es ainsi que ses utilisateurs. Dans ce cas l√†, il faut se positionner dans une autre base de donn√©es et lancer cette commande : 

```sql
SELECT pg_terminate_backend(pg_stat_activity.pid)
FROM pg_stat_activity
WHERE pg_stat_activity.datname = 'NOM_DB' 
  AND pid <> pg_backend_pid();
```
Cette commande permet de tuer un processus serveur. 
</script></section></section><section ><section data-markdown><script type="text/template">## SQL avanc√©

### Donn√©es raster

![](assets/images/vector_raster.jpg)

</script></section><section data-markdown><script type="text/template">

#### La gestion de raster dans PostGIS

- Depuis la version 2.0, PostGIS peut associer un ensemble de cellules
 raster √† un enregistrement gr√¢ce au type de donn√©es raster.

- Ce type de donn√©es est associ√©s √† diverses fonctions de gestions
 mais aussi √† de puissantes fonctions d'analyse raster-vecteur.

- Raster2pgsql est l'utilitaire fourni dans PostGIS pour importer un jeu de donn√©es raster dans Postgres.

- Le stockage du raster dans la base accentue encore les probl√®mes de
 performance et de consommation de ressources syst√®me.

</script></section><section data-markdown><script type="text/template">

#### La gestion de raster dans PostGIS

- Possibilit√© de ¬´¬†draper¬†¬ª des donn√©es sur un Mod√®le Num√©rique.
 de Terrain (__MNT__).
- Possibilit√© de tuiler (et indexer) les dalles.
- Supporte tous les formats g√©r√©s par __GDAL__.

![](assets/images/mnt.png)
</script></section><section data-markdown><script type="text/template">

### Pratique

#### SQL avanc√©

**Exercices 4 : Rasters**

- 4.1 Analyse spatiale raster-vecteur
- 4.2 Altitude moyenne
- 4.3 (BONUS) Draper une ligne sur le MNT
- 4.4 (BONUS) Profil altim√©trique
</script></section></section><section ><section data-markdown><script type="text/template">## SQL avanc√©

### Validit√© g√©om√©trique

<img src="assets/images/geometrie_invalides2.png" width="450">

[Source : gis.stackovernet]( https://gis.stackovernet.com/fr/q/34051)
</script></section><section data-markdown><script type="text/template">
#### Les g√©om√©tries invalides

Une g√©om√©trie invalide est l'une des causes les plus courantes de l'√©chec de requ√™tes spatiales.

* Seuls les polygones peuvent √™tre invalides.
* Quelques r√®gles de validation:
   - Les contours doivent √™tre ferm√©s
   - Les contours ne doivent pas s'autointersecter

Ces r√®gles sont importantes car les algorithmes de calcul d√©pendent de la structure et la coh√©rence g√©om√©trique de ces polygones.
</script></section><section data-markdown><script type="text/template">
#### Les g√©om√©tries invalides
- Voici un polygone en forme de 8

<img style="left" src="assets/images/polygone_invalide.png" alt="drawing" width="100"/>


- Essayons de calculer son aire :

```sql
SELECT ST_Area(ST_GeometryFromText
('POLYGON((0 0, 0 1, 1 1, 2 1, 2 2, 1 2, 1 1, 1 0, 0 0))')) as aire;
```

R√©sultat :

|aire|
|----------|
|0|

Les aires qui sont calcul√©es pour chaque carr√© s'annulent.

</script></section><section data-markdown><script type="text/template">
#### D√©tecter les g√©om√©tries invalides


- ```ST_Area() ``` peut retourner une valeur √©gale √† 0¬†!
- ```ST_IsValid(geom)``` renvoie un bool√©en
- ```ST_IsValidReason(geom)``` renvoie la cause de l‚Äôinvalidit√©.
- ```ST_IsValidDetail(geom, integer flags)``` rapport d√©taill√© des g√©om√©tries valides/invalides.

Les principales erreurs de g√©om√©tries:
![](assets/images/geometriesinvalides.png)
</script></section><section data-markdown><script type="text/template">

<img  src="assets/images/geometriesinvalides.png" alt="drawing" width="300"/>

|Type d'erreur|D√©finition|
|----------|:-------------:|
|Hole Outside Shell|Trou ext√©rieur √† l'enveloppes||
|Nested Holes|Trou imbriqu√©|
|Disconnected Interior|Le trou touche le polygone en plus de 1 point|
|Self Intersection|Auto-intersection|
|Ring Self Intersection|Anneau auto-intersectant avec r√©duction de l'anneau en un point|
|Nested shell|Polygones imbriqu√©s|



</script></section><section data-markdown><script type="text/template">

#### G√©rer les g√©om√©tries invalides

- Correction automatique (r√©sultats al√©atoires):
   - __St_Makevalid__ tente de r√©parer les g√©om√©tries avec les cas d'invalidit√©s les plus fr√©quents (auto-intersection, trous invalides)
   - __ST_Buffer(geom,0)__ cr√©e une zone tampon nulle pour reconstruire les g√©om√©tries
- Correction manuelle avec un logiciel SIG (si motiv√©)

</script></section><section data-markdown><script type="text/template">

### Pratique

#### Probl√®mes g√©om√©triques
**Exercice 5 : Op√©rations g√©om√©triques complexes**

- 5.1 D√©tection d'anomalies
- 5.2 D√©tection des polygones multiples
- 5.3 D√©tection de chevauchement
- 5.4 (BONUS) D√©tection des b√¢timents juxtapos√©s
- 5.5 (BONUS) Correction automatique les g√©om√©tries invalides

</script></section><section data-markdown><script type="text/template">
#### Pour aller plus loin

Pour en savoir plus :
- Workshop Foss4g : [Validity](http://www.postgis.fr/chrome/site/docs/workshop-foss4g/doc/validity.html)
- Sigterritoires : [Corriger la g√©om√©trie d'une table](https://www.sigterritoires.fr/index.php/corriger-la-geometrie-dune-table-postgis/)
</script></section></section><section ><section data-markdown><script type="text/template">## SQL avanc√©

### Topologie
<img src="assets/images/topologicalmap.jpeg" width="450">

üëâ Tweet : https://twitter.com/tillnm/status/1269576945999785984
</script></section><section data-markdown><script type="text/template">

#### La topologie en quelques mots

- Traite des notions de continuit√© et de voisinage
- En SIG permet de v√©rifier la coh√©rence g√©om√©trique entre plusieurs objets d'une m√™me couche d'information

- Avec le type geometry, chaque forme est ind√©pendante des autres. Cela
 peut mener √† des incoh√©rences spatiales au niveau de la table.

 </script></section><section data-markdown><script type="text/template">

#### La topologie dans PostGIS

Passage d'un ensemble de g√©om√©tries √† un **graphe** (compos√© de noeuds et d'arcs)

![](assets/images/geom_topologies.png)

* Gains en taille m√©moire
* V√©rification de la coh√©rence facilit√©e


</script></section><section data-markdown><script type="text/template">

#### La topologie dans PostGIS

- Le support des topologies est fournie par l'extension
  `postgis_topology`.

- Le principe est de stocker l'information g√©ographique au niveau de la
 couche topologique gr√¢ce aux primitives __nodes__, __edges__ et __faces__.

- Dans les tables, les formes sont alors de type __topogeometry__ et ne sont
 que l'agr√©gation de primitives topologiques.

</script></section><section data-markdown><script type="text/template">

#### Topologies et simplifications

- La superposition des n≈ìuds et arcs est conserv√©e
<!-- ![](assets/images/topologie_ko.png)    ![](assets/images/topologie_ok.png)
 -->
<table><tr>
<td> <img src="assets/images/topologie_ko.png" width="450" alt="Le scandale de Mercator"/> </td>
<td> <img src="assets/images/topologie_ok.png" width="450" alt="Le scandale de Mercator"/> </td>
</tr></table>

</script></section><section data-markdown><script type="text/template">

#### Routing

![](assets/images/isochrones.png)
[Source : master SIGAT](https://www.sites.univ-rennes2.fr/mastersigat/Webmapping/AtelierKoumoul/pages/isochrones/index_isochrones.html) 

[pgRouting](http://pgrouting.org/) est une extension de Postgis qui fournit des fonctionnalit√©s de routage geospatial et d'analyse de r√©seaux.

</script></section><section data-markdown><script type="text/template">	

Quels sont les avantages du routage ?

- R√©duction des co√ªts de trajet
- Gain de temps
==> Par cons√©quent, r√©duction des √©missions de CO2.

</script></section><section data-markdown><script type="text/template">	

`pgRouting` contient les algorithmes suivants :

- All Pairs Shortest Path, Johnson‚Äôs Algorithm
- All Pairs Shortest Path, Floyd-Warshall Algorithm
- Shortest Path Dijkstra
- Shortest Path A*
- Bi-directional Dijkstra Shortest Path
- Bi-directional A* Shortest Path
- Driving Distance
- K-Dijkstra, One to Many Shortest Path
- K-Shortest Path, Multiple Alternative Paths
- Traveling Sales Person
- Turn Restriction Shortest Path (TRSP)


</script></section><section data-markdown><script type="text/template">	

Plus de d√©tails sur ces fonctions dans cette [documentation](http://www.postgis.fr/chrome/site/docs/workshop-routing-foss4g/docs/pgRoutingWorkshop.pdf).

Ces algorithmes vont nous permettre de r√©aliser des **calculs de distance**,  des **analyses de plus court chemin** et des **calculs d'isochrones**.

* Exemples de mise en application :
    * *[Find your way with the power of PostGIS & pgRouting](https://blog.daftcode.pl/find-your-way-with-the-power-of-postgis-pgrouting-66d620ef201b)*
    * *[Temps moyen d‚Äôacc√®s √† la gare SNCF de Rennes](https://diouck.wordpress.com/postgispgrouting/)*

</script></section><section data-markdown><script type="text/template">
#### Pratique 

**Exercices 6 : Topologie et Routing** 

- 6.1 Import de shapefile avec Shp2pgsql
- 6.2 Cr√©ation de la topologie du r√©seau
- 6.3 Routing - Calcul des temps distance pour diff√©rents modes de transport
- 6.4 Routing - Calcul de plus court chemin (BONUS)
- 6.5 Routing - Calcul de plus chemins multiples (BONUS)


</script></section></section><section ><section data-markdown><script type="text/template">## Administration PostgreSQL

### Gestion des utilisateurs

<img src="assets/images/gestionutilisateur.png" width="500">

</script></section><section data-markdown><script type="text/template">

#### R√¥les, droits et privil√®ges

- Une fois connect√©, PostgreSQL s'appuie sur les concepts de ```r√¥les```, de
 ```droits``` et de ```privil√®ges```.
- Un r√¥le peut √™tre un utilisateur ou un groupe.

![](assets/images/roles.png)
Source : [ENSG](http://cours-fad-public.ensg.eu/mod/imscp/view.php?id=701)

</script></section><section data-markdown><script type="text/template">

- Un r√¥le est un ```ensemble de droits et de privil√®ges```.
- Un r√¥le peut h√©riter d'un autre r√¥le.
- Les droits sont d√©finis pour chaque objet.
- Le propri√©taire d'un objet a tous les droits dessus.
- Les privil√®ges sont ```SUPERUSER```, ```CREATEDB```, ```CREATEROLE```, ```CREATEUSER```, ```LOGIN```


</script></section><section data-markdown><script type="text/template">

#### R√¥les, droits et privil√®ges

- Pour qu'un utilisateur ait tous les droits sur une table¬†:
```sql
ALTER TABLE <table> OWNER TO <role>¬†;
```

</script></section><section data-markdown><script type="text/template">

#### Attribution des droits

A retenir :
**seul le super utilisateur est capable de g√©rer les utilisateurs dans pgadmin**.
Avec des connexions de moindre niveau vous n'aurez plus la possibilit√© de cr√©er ou modifier les utilisateurs et groupes.

</script></section><section data-markdown><script type="text/template">

#### Attribution des droits

- On attribue les droits gr√¢ce √† ```GRANT``` et ```REVOKE```.

```sql
-- Cr√©ation d'un super-utilisateur
-- (SUPERUSER implique CREATEDB et CREATEROLE)
CREATE ROLE admin LOGIN SUPERUSER;
-- Il faut avoir le droit SUPERUSER pour cr√©er un
-- nouveau superutilisateur.

-- Cr√©ation d'un groupe
CREATE ROLE gisreader;
-- Un r√¥le disposant du droit CREATEROLE peut aussi
-- modifier et supprimer d'autres r√¥les, ainsi que
-- donner ou supprimer l'appartenance √† ces r√¥les.
```
</script></section><section data-markdown><script type="text/template">
```sql
-- Cr√©ation d'un utilisateur appartenant √† un groupe
CREATE ROLE martin LOGIN;
GRANT gisreader TO martin;

-- Attribution de privil√®ge √† un groupe
REVOKE SELECT ON <table> FROM public;
GRANT SELECT ON <table> TO gisreader;
```

</script></section><section data-markdown><script type="text/template">

#### Avec PgAdmin

- Attention √† la date de validit√© attribu√©e automatiquement par
 PgAdmin¬†!
 </script></section><section data-markdown><script type="text/template">

### Pratique

#### Gestion des droits

**Exercice 7 : Administration Postgres**

- 7.1 Gestion des droits
</script></section></section><section ><section data-markdown><script type="text/template">## Administration PostgreSQL

### Import/Export des donn√©es
<img src="assets/images/import_export.jpg" width="300">


</script></section><section data-markdown><script type="text/template">

#### Lecture et √©criture au format CSV

- La commande __COPY__ permet d'importer et d'exporter des donn√©es depuis
 des fichiers CSV.
- Import :
```sql
COPY parcelle (id_parcelle, insee, id_section)
FROM '/tmp/fichier.csv' WITH DELIMITER ',' CSV HEADER;
```
- Export :
```sql
COPY (SELECT * FROM parcelle)
TO '/tmp/fichier.csv' WITH DELIMITER ',' CSV HEADER;
```
- Requiert le droit __SUPERUSER__.

</script></section><section data-markdown><script type="text/template">

#### ogr2ogr

- Le programme ```ogr2ogr``` est le __couteau suisse__ de l'int√©grateur de
 donn√©es spatiales.
- Plus de __20 formats vectoriels__ support√©s.
- Utilitaire en mode console.
- Fonctionne en mode __ETL__¬†: lit une source de donn√©es, encha√Æne
 filtres et transformations, √©crit dans le format cible.

</script></section><section data-markdown><script type="text/template">

#### ogr2ogr

- Export d'une table PostGIS vers un ShapeFile avec filtrage
 attributaire, filtrage sur l'emprise et reprojection¬†:
- Requiert privil√®ge SUPERUSER.

```bash
export PGCLIENTENCODING="LATIN1"
ogr2ogr
   -f "ESRI Shapefile" sortie.shp
   PG:"host=... user=... dbname=... password=..." table
   -t_srs EPSG:2154
   -where "cde_dep = 11"
   -spat 548976, 1704978, 802810, 1996720
```

</script></section><section data-markdown><script type="text/template">

#### shp2pgsql

- Le programme ```shp2pgsql``` est fourni avec PostGIS.
- Il est fait pour charger des ShapeFile dans PostGIS.
- L'option ```-W``` sp√©cifie l'encodage d'entr√©e.
- L'option ```-I``` ajoute un index g√©om√©trique.
- L'option ```-s <srid>``` indique le syst√®me de coordonn√©es.

```bash
shp2pgsql -I -W LATIN1 shapefiles-rge/batiment.shp batiment
| psql -d formation -U user -h localhost
```


</script></section><section data-markdown><script type="text/template">

#### raster2pgsql

- Le programme ```raster2pgsql``` est fourni avec PostGIS.
- Il est fait pour charger des rasters dans PostGIS.
- L'option ```-I``` ajoute un index g√©om√©trique.
- L'option ```-C``` ajoute les contraintes du raster.
- L'option ```-M``` nettoie la table (VACUUM ANALYZE).
- L'option ```-s <srid>``` indique le syst√®me de coordonn√©es.
```bash
raster2pgsql -s 27572 -I -C -M srtm-27572.tif srtm
| psql -d formation -U user -h localhost
```

</script></section><section data-markdown><script type="text/template">

#### Outils graphiques

- Une partie des fonctionnalit√©s OGR sont accessibles dans des SIG
 comme QGIS.

- ```shp2pgsql``` et ```pgsql2shp``` sont disponibles en tant que plugins dans
 pgAdmin4.

- L'ETL spatial FME de Safe software est assez courant et facile √†
 utiliser.

- L'ETL Talend propose l'extension spatiale Spatial Data Integrator
 (SDI).


</script></section><section data-markdown><script type="text/template">
### Pratique

#### Import et export

**Exercice 7 : Administration Postgres**

- 7.2 Import et export de CSV
- 7.3 Import et export avec Ogr2ogr, shp2pgsql et raster2pgsql
</script></section></section><section ><section data-markdown><script type="text/template">## Administration PostgreSQL

### Mise √† jour

</script></section><section data-markdown><script type="text/template">

### Mises √† jour

- Avant de faire une mise √† jour de PostgreSQL ou PostGIS, __fa√Ætes
 toujours une sauvegarde__ de vos bases de donn√©es.
- Notez que les mises √† jour de PostGIS ne modifient jamais vos bases
 de donn√©es, seulement les biblioth√®ques et scripts d'installation.
- PostGIS propose des outils de __soft upgrade__ (mise √† jour de PostGIS
 dans une base existante).
- Lorsque le soft upgrade √©choue, le __hard upgrade__ consiste √† migrer
 les donn√©es vers une nouvelle base.

</script></section><section data-markdown><script type="text/template">

### Proc√©dure de ¬´¬†soft upgrade¬†¬ª

- Vous pouvez utiliser la commande¬†:
```sql
ALTER EXTENSION postgis UPDATE TO '3.0.2'¬†;
```
- Si le soft upgrade n'est pas possible, la proc√©dure √©chouera avec un
 message d'erreur (sans rien modifier).
</script></section></section><section ><section data-markdown><script type="text/template">## Administration PostgreSQL

### Configuration du serveur

</script></section><section data-markdown><script type="text/template">

#### Fichiers de configuration

- La configuration de PostgreSQL est d√©finie au niveau du ```cluster```.
- Un ```cluster``` est un espace de stockage (contenant plusieurs bases)
 associ√© √† une instance du serveur.
- A la racine du ```cluster``` se trouvent les fichiers :
  - __postgresql.conf__ pour la configuration du serveur PostgreSQL
  - __pg_hba.conf__ et __pg_ident.conf__ pour la gestion des utilisateurs
- On peut aussi cr√©er plusieurs __tablespace__ pour r√©partir le stockage
 (*optimisation*).

</script></section><section data-markdown><script type="text/template">

#### Fichier postgresql.conf

- Dans le fichier __postgresql.conf__, la plupart des options sont
 r√©serv√©es √† un usage avanc√© et concernent l'optimisation du serveur
 pour un usage particulier.
 
- La section ¬´¬†connections and authentification¬†¬ª inclut :
  - ```listen_addresses``` qui d√©finit les adresses depuis lesquelles on
 accepte les connexions. Par d√©faut : '*' (le serveur √©coute tout).
  - ```port``` qui d√©finit le port sur lequel le service attend les connexions

</script></section><section data-markdown><script type="text/template">

#### Gestion des connexions

- La gestion de l'authentification est g√©r√©e dans __pg_hba.conf__, elle
 combine nom d'utilisateur et h√¥te de connection.
 
 Ce fichier est pr√©sent dans le r√©pertoire initialis√© avec l'instance postgres.
 
- Les principales m√©thodes d'authentification sont ```ident```, ```md5``` et ```trust```
 :
  - ```ident``` s'appuie sur les utilisateurs du syst√®me,
  - ```md5``` utilise le cryptage du mot de passe,
  - ```trust``` d√©sactive l'authentification (d√©conseill√©).
 
 </script></section><section data-markdown><script type="text/template">
 
- Il existe d'autres m√©thodes d'authentification pour exploiter les
 infrastructures disponibles sur le r√©seau.
 
**Attention, n'oubliez pas de red√©marrer PostgreSQL quand vous modifiez le pg_hba.conf !**

 </script></section><section data-markdown><script type="text/template">
#### Quelques modes d'authentification

- Permettre √† n'importe quel utilisateur du syst√®me local de se connecter √† la base de donn√©e sous n'importe quel nom d'utilisateur :


| TYPE| DATABASE|USER|ADDRESS|METHOD|
|----------|:-------------:|------:|------:|------:|
|local|all|all||trust|

- La m√™me chose en utilisant les connexions TCP/IP locales loopback en utilisant une authentification par mot de passe :


| TYPE| DATABASE|USER|ADDRESS|METHOD|
|----------|:-------------:|------:|------:|------:|
|local|all|all|127.0.0.1/32|md5|

 </script></section><section data-markdown><script type="text/template">

- La m√™me chose en utilisant le nom d'h√¥te avec l'authentifiaction par mot de passe:


| TYPE| DATABASE|USER|ADDRESS|METHOD|
|----------|:-------------:|------:|------:|------:|
|local|all|all|localhost|md5|

- N'autorise les utilisateurs locaux qu'√† se connecter √† leur propre base de donn√©e (base ayant le m√™me nom que leur nom d'utilisateur) exception faite des administrateurs et des membres du r√¥le "support" qui peuvent se connecter √† toutes les bases de donn√©es:


| TYPE| DATABASE|USER|ADDRESS|METHOD|
|----------|:-------------:|------:|------:|------:|
|local|sameuser|all||md5|
|local|all|@admins,+support||md5|


[ Pour en savoir plus]( https://docs.postgresql.fr/10/client-authentication.html)

 </script></section><section data-markdown><script type="text/template">


Une autre tactique possible est d'ouvrir les droits de connexion aux utilisateurs dans le fichier pg_hba.conf et de contr√¥ler plus finement la gestion des droits d'acc√®s par base dans la gestion des droits et r√¥les de PostgreSQL. Cela a l'avantage d'√©viter de solliciter trop souvent l'administrateur syst√®me et de reporter la gestion des droits courants (autre que le filtrage d'IP) sur l'administrateur des bases de donn√©es.

Pour autant cette m√©thode n'est **pas toujours souhaitable** car, l'utilisateur m√™me sans avoir les droits des bases, pourra quand m√™me parcourir l'aborescence des bases.</script></section></section><section ><section data-markdown><script type="text/template">## Administration PostgreSQL

### Notion de service

</script></section><section data-markdown><script type="text/template">

#### Notion de service

- PostgreSQL doit √™tre vu comme un service :
  - il est en veille permanente,
  - il g√®re la r√©ception des requ√™tes, leur traitement et l'envoi des
 r√©ponses.
 
- Par d√©faut, PostgreSQL est lanc√© automatiquement au d√©marrage.

- On peut contr√¥ler le service PostgreSQL par l'interface de gestion
 des services, permettant notamment de d√©sactiver le d√©marrage
 automatique.

</script></section><section data-markdown><script type="text/template">

#### Gestionnaire de service

![](assets/images/services_windows.png)</script></section></section><section ><section data-markdown><script type="text/template">## Administration PostgreSQL

### Sauvegarde et restauration

<img src="assets/images/postgresql-db-backup.jpg" width="400">
</script></section><section data-markdown><script type="text/template">

#### Outils standards

- PostgreSQL est ¬´¬†livr√©¬†¬ª en standard avec :
  - ```pg_dump``` (sauvegarde d'une base de donn√©es),
  - ```pg_dumpall``` (sauvegarde du cluster complet),
  - ```pg_restore``` (restauration).

- Les deux processus sont largement configurables.

- Il s'agit de programme en mode console.

- PgAdmin4 offre une interface graphique convenable.

- Restauration sur crash possible (snapshot+WAL)

</script></section><section data-markdown><script type="text/template">

#### Options

- Format ```plain``` pour g√©n√©rer un script SQL, sinon format ```custom```.
- Exporter les ¬´¬†blobs¬†¬ª (binary large objects) pour les bases g√©ographiques.
- Dans le cas d'un export, d√©sactiver les options ¬´¬†Propri√©taire¬†¬ª
 et ¬´¬†Droits¬†¬ª.
- Pensez √† faire des sauvegardes au niveau cluster pour conserver la
 d√©finition des utilisateurs.

[ Pour aller plus loin ](https://wiki.postgresql.org/wiki/Automated_Backup_on_Linux)

</script></section><section data-markdown><script type="text/template">


### Pratique

#### Sauvegarde et restauration

**Exercice 7 : Sauvegarde et restauration**

- 7.4 Sauvegarde et restauration

</script></section></section><section ><section data-markdown><script type="text/template">## Administration PostgreSQL

### Synchronisation et r√©plication

</script></section><section data-markdown><script type="text/template">

#### Objectif

- __High-availability__ : minimiser le temps de reprise en cas de panne.

- __Load-balancing__ : r√©partir la charge pour am√©liorer les temps de
 r√©ponse.
 
- Id√©alement, la solution de r√©plication est transparente pour
 l'utilisateur.
 
- Id√©alement, la solution n'a pas d'impact n√©gatif sur la performance.

- L'id√©al n'existe pas.

</script></section><section data-markdown><script type="text/template">

#### Solutions

- Quelques solutions :
  - cluster partag√©,
  - cluster r√©pliqu√©,
  - syst√®me ma√Ætre-esclave,
  - r√©plication des transactions (flux),
  - OS.
  
- Chaque solution a des avantages et des inconv√©nients.

- M√™mes versions, m√™me stockage binaire (32/64bits)

</script></section></section><section ><section data-markdown><script type="text/template">## SQL tr√®s avanc√©

### Triggers et fonctions

<img src="assets/images/triggerpostgres.jpg" width="700">
</script></section><section data-markdown><script type="text/template">

#### Fonctions

- PostgreSQL supporte plusieurs langages pour √©crire des fonctions
 personnalis√©e : SQL, C, PL/PgSQL, Python, Perl, ‚Ä¶
- A priori, tout est permis.
- Attention √† la gestion de la m√©moire !

</script></section><section data-markdown><script type="text/template">

#### Pr√©sentation de la syntaxe d'une fonction PL/PgSQL

```sql
-- nom de la fonction
CREATE FUNCTION nomfonction(varchar, integer)
-- type de retour sp√©cial trigger
RETURNS trigger AS $$
-- r√©sultat de la fonction
RETURNS integer AS $$
-- declaration des variables
DECLARE
-- code de la fonction
BEGIN
-- fin du code de la fonction
END;
$$ LANGUAGE plpgsql;
```
</script></section><section data-markdown><script type="text/template">

#### Quelques mots cl√©s √† retenir de PL/PgSQL

-  ```;  ```d√©limite la fin du code de la fonction
-  ```:=  ``` assignation de variable.
-  ```BEGIN ‚Ä¶ END ``` d√©limitent un bloc de code.
-  ```RETURN ``` permet de retourner une valeur (s'√©crit en dehors du code)
-  ```DECLARE ``` permet de d√©clarer des variables locales.

</script></section><section data-markdown><script type="text/template">

Exemple:

```sql
CREATE FUNCTION F_ECART_JOUR(d DATE)
RETURNS INTEGER
AS
$corps$
DECLARE jour date := CURRENT_DATE;
        nombre_jour INTEGER;
BEGIN
   nombre_jour := jour - d;
   RETURN nombre_jour;
END;
$corps$
LANGUAGE PLPGSQL
```

Cette fonction renvoit l'√©cart en nombre de jours entre une date pass√©e et la date du jour.
```sql
SELECT F_ECART_JOUR(DATE('2019-07-30'))
```

*Source : [Blog developpez sqlpro](https://blog.developpez.com/sqlpro/p10060/langage-sql-norme/postgresql_syntaxe_basique_des_fonctions)*

</script></section><section data-markdown><script type="text/template">
#### Triggers
- Un trigger est un programme qui se d√©clenche automatiquement √† la suite d'un √©v√®nement.
- Les triggers associent un traitement personnalis√© √† chaque
 modification d'une table (ou d'une vue).

- Cas fr√©quents d'utilisation¬†:
  - v√©rification de contraintes complexes,
  - renseignement d'attributs calcul√©s,
  - propagation de modification vers d'autres tables.

- Un trigger peut avoir acc√®s √† la donn√©e en cours d'√©dition (et
 m√™me la modifier).

 /!\ Ne pas en abuser car l'inter-d√©pendance entre triggers peut √™tre difficile √† g√©rer, surtout lorsque le mod√®le de donn√©es est vou√© √† √©voluer.

</script></section><section data-markdown><script type="text/template">
#### Pr√©sentation de la syntaxe d'un trigger

```sql
-- nom du trigger
CREATE [OR REPLACE] TRIGGER  nomtrigger
-- √©v√®nements
BEFORE|AFTER INSERT [OR]|UPDATE [OR]|DELETE
-- nom de la table √† mettre √† jour
[OF nomcolonne] ON nomtable
-- condition d'ex√©cution
FOR EACH ROW | EACH STATEMENT
EXECUTE PROCEDURE nomfonction()
;
```
</script></section><section data-markdown><script type="text/template">
#### Options des triggers

- Un trigger est associ√© √† un √©v√©nement __INSERT__, __UPDATE__ ou __DELETE__.
- Un trigger peut r√©agir √† chaque enregistrement modifi√© ou √† chaque
 ordre SQL.
- Un trigger peut r√©agir en amont ou en aval de la modification.
- L'action d√©clench√©e est d√©crite par une fonction.

</script></section><section data-markdown><script type="text/template">
Il peut y avoir 4 sortes de triggers possibles selon le moment (BEFORE, AFTER) et le type (instruction ou ligne).

Voici un r√©capitulatif ce qu'il est possible de faire selon les cas d'usage :

![](assets/images/triggers.png)

Source : [Postgresql](https://www.postgresql.org/docs/9.1/static/sql-createtrigger.html)

</script></section><section data-markdown><script type="text/template">

#### Trigger BEFORE ou AFTER ?

- **BEFORE** : Le trigger est d√©clench√© avant que le changement soit effectu√© dans la table.
- **AFTER** : Le trigger est d√©clench√© apr√®s que les changements aient √©t√© effectu√©s dans la table.

</script></section><section data-markdown><script type="text/template">

<img src="assets/images/trigger_before_after.png" width="400">

Source : [When to use "before" vs "after" triggers](http://www.sfdc99.com/2014/01/25/use-vs-triggers/)

La majorit√© des triggers sont des BEFORE.

</script></section><section data-markdown><script type="text/template">

#### Trigger ligne ou instruction?

- Le trigger ligne (**FOR EACH ROW**) :
  - Va se d√©clencher une fois pour chaque ligne modifi√©e/ins√©r√©e/supprim√©e.
  - Possiblit√© d'ajouter une condition suppl√©mentaire **WHEN**.
  - Notions de ligne courantes :
     - *old* :
         - d√©signe la ligne avant modification
         - type de donn√©e RECORD
         - valable pour un DELETE et un UPDATE
     - *new*
         -  d√©signe la ligne apr√®s modification
         - type de donn√©e RECORD
         - valable pour un INSERT et un UPDATE


![](assets/images/ligne_courante_trigger.png)

Source :[ Les triggers - - Licence MIAGE - Universit√© Lille 1](http://www.fil.univ-lille1.fr/~caronc/BDD/triggersPar4.pdf)

- Le trigger instruction (**FOR EACH STATEMENT**):
  - Va se d√©clencher une seule fois pour toute l'instruction.


</script></section><section data-markdown><script type="text/template">

#### Exemple de trigger

```sql
CREATE FUNCTION maj_surface() RETURNS trigger AS $$
BEGIN
 NEW.area := ST_Area(NEW.geom);
 RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER maj_surface
BEFORE INSERT OR UPDATE ON geotable
FOR EACH ROW EXECUTE PROCEDURE maj_surface();
```


</script></section><section data-markdown><script type="text/template">

### Pratique

#### SQL tr√®s avanc√©

**Exercice 8 : Triggers et fonctions**

- 8.1 Mise √† jour de champ
- 8.2 Fonctions et triggers

  </script></section><section data-markdown><script type="text/template">
### Pour aller plus loin:
- [Blog sigterritoires -Postgresql et PL/pgsql: une petite initiation aux fonctions](https://www.sigterritoires.fr/index.php/postgresql-et-pl-pgsql-une-petite-initiation-aux-fonctions/)
- [Blog developpez sqlpro](https://blog.developpez.com/sqlpro/p10060/langage-sql-norme/postgresql_syntaxe_basique_des_fonctions)
- [Lille Universit√© - PL/pgSQL : Instructions de base](https://archive.is/FfXNb)
- [IGM Gaspard Monge - PL/pgSQL](http://www-igm.univ-mlv.fr/~dr/XPOSE2005/cocquet/fonctions_postgresql.html)
- [PL/pgSQL avanc√© ](https://public.dalibo.com/exports/formation/manuels/modules/p2/p2.handout.html)
</script></section></section><section ><section data-markdown><script type="text/template">## SQL tr√®s avanc√©

### Notion de transaction

</script></section><section data-markdown><script type="text/template">

#### Syst√®mes multi-utilisateurs

- Le traitement d'une requ√™te n'est jamais instantan√©. Toute
 op√©ration sur la base de donn√©es a une __dur√©e__.
- En cas d'√©dition, la base peut passer dans un √©tat __incoh√©rent__
 pendant le temps de ce traitement.
- Pendant ce m√™me temps, il est aussi possible qu'un autre utilisateur
 cherche √† modifier les m√™mes donn√©es. Il y alors risque
 d'√©crasement.
- Pour pr√©server l'__int√©grit√©__ de la base, on a alors recours aux
 __transactions__.

</script></section><section data-markdown><script type="text/template">

#### Caract√©ristiques des transactions

- Une transaction est un ensemble d'op√©rations ayant les propri√©t√©s
 suivantes :
  - __Atomicit√©__ : une transaction ne peut pas √™tre subdivis√©e, soit elle
 a lieu jusqu'au bout soit elle n'a pas lieu,
  - __Coh√©rence__ : une transaction trouve la base dans un √©tat coh√©rent et
 la laisse dans un √©tat coh√©rent,
  - __Isolation__ : les modifications engendr√©es par une transaction ne sont
 pas visible par les autres utilisateurs avant la fin de la transaction,
  - __Durabilit√©__ : quand la transaction termine, les modifications
 engendr√©es sont d√©finitives.

</script></section><section data-markdown><script type="text/template">

#### Les transactions dans PostgreSQL

- Toute requ√™te envoy√©e √† PostgreSQL s'inscrit dans le cadre d'une
 transaction (mais les logiciels clients peuvent g√©rer un mode
 auto-commit).
 
- Une transaction peut se terminer de deux mani√®res¬†:
  - un __COMMIT__ confirme les modifications et les √©crit dans la base,
  - un __ROLLBACK__ annule toutes les modifications ayant √©t√© apport√©es
 pendant la transaction.
- En cas d'erreur/√©chec, la transaction est termin√©e par un __ROLLBACK__.

</script></section><section data-markdown><script type="text/template">

#### Contr√¥le des transactions

- En __SQL__, la transaction commence avec __BEGIN__ et se termine avec __COMMIT__
 ou __ROLLBACK__ :
```sql
BEGIN;
UPDATE ... ;
DELETE ... ;
DELETE ... ;
COMMIT;
```
- Utile dans le cas de scripts pour √©viter de laisser une proc√©dure √†
 moiti√© termin√©e apr√®s une erreur.
- Les modifications ne sont visibles par les autres utilisateurs
 qu'apr√®s un __COMMIT__.

</script></section></section><section ><section data-markdown><script type="text/template">## Pour r√©sumer

### Les bonnes pratiques

</script></section><section data-markdown><script type="text/template">

#### Serveur :

- Bien configuer les ouvertures vers l'ext√©rieur (postgresql.conf et pg_hba.conf)
- Travailler de pr√©f√©rence dans d'autres sch√©mas que "public" qui contient les tables syst√®mes PostGIS, les fonctions, etc. De plus, l'organisation des donn√©es en plusieurs sch√©mas simplifie la gestion des droits d'utilisation ainsi que les proc√©dures de restauration.


</script></section><section data-markdown><script type="text/template">

####  S√©curit√© :

- Gestion des acc√®s utilisateurs et des roles pour assurer l'int√©grit√© des donn√©es
- Dans un serveur en production, faire des sauvegardes r√©guli√®rement (au minimum), le mieux √©tant de mettre en place un syst√®me de r√©plication (√† calibrer selon les besoins)

</script></section><section data-markdown><script type="text/template">

####  Optimisation de la base de donn√©es :

- R√©fl√©chir √† l'organisation de son mod√®le de donn√©es avant de cr√©er ses tables.
- Gestion des contraintes (cl√©s primaires/√©trang√®res)
- VACUUM pour r√©cup√©rer l'espace disque non utilis√© et ANALYSE pour r√©cup√©rer l'information statistique afin d'optimiser les requ√™tes
- Indexation pour les tables ayant √©t√© modifi√©es massivement
- V√©rifier la validit√©e des g√©om√©tries
- R√©partir les tables volumineuses sur plusieurs tables (avantage : meilleure efficience des index)

</script></section><section data-markdown><script type="text/template">

#### Optimiser les requ√™tes:

- Utiliser des sous-requ√™tes plut√¥t que de cr√©er de nouvelles tables
- Ne pas utiliser de fonctions d√©pr√©ci√©es
- Tester plusieurs requ√™tes permettant d'arriver au m√™me r√©sultat pour √©valuer leur rapidit√©

</script></section><section data-markdown><script type="text/template">

### Pour aller plus loin :

- [Les supports p√©dagogiques de G√©oinformations]( http://www.geoinformations.developpement-durable.gouv.fr/postgis-support-pedagogique-a3347.html)
- [Cours et tutoriel sur le language SQL](https://sql.sh/)
- [Cours Postgres avanc√© de l'ENSG](http://cours-fad-public.ensg.eu/course/view.php?id=129)
- [Don't do this ](https://wiki.postgresql.org/wiki/Don%27t_Do_This)
</script></section></section><section ><section data-markdown><script type="text/template">## SQL tr√®s avanc√©

### Les tuiles vectorielles

![](assets/images/age_batiments_tuiles_vectorielles.png)

[Source](https://parallel.co.uk/netherlands/#13.8/52.365/4.9/0/40) 


</script></section><section data-markdown><script type="text/template">
#### Les tuiles vectorielles

<img src="assets/images/tuiles.png" alt="drawing" width="300"/>
‚áí
Ensemble d‚Äôimages de 256x256 pixels

- Les cartes sur le web sont aujourd‚Äôhui compos√©es de **tuiles**. Ce sont de petits morceaux de cartes, des carr√©s, mis les uns √† suite des autres. Initialement ces **tuiles** √©taient des images bitmaps, mais elles sont progressivement remplac√©es par des **tuiles vectorielles**. 
- Les **tuiles vectorielles** sont des morceaux de cartes contenant les donn√©es n√©cessaires √† la repr√©sentation d‚Äôune zone. 

</script></section><section data-markdown><script type="text/template">
#### Caract√©ristiques des tuiles vectorielles

* Principe de tuiles conserv√©
* Donn√©es brutes vectorielles plut√¥t que des images pr√©calcul√©es
* Propri√©t√©s des objets accessibles
* Format binaire Protobuf
* Rendu par le client

</script></section><section data-markdown><script type="text/template">
#### Caract√©ristiques des tuiles vectorielles

- Pour servir ces donn√©es sous forme de tuiles vectorielles, il est n√©cessaire de les pr√©parer, de les mettre √† disposition via un serveur et de les afficher sur le web en leur appliquant des styles graphiques. 

- Les tuiles vectorielles contiennent les g√©om√©tries qui composent la carte et non plus des dessins fig√©s de celle-ci

![](assets/images/square-of-math.gif) <!-- .element height="300px"  -->
</script></section><section data-markdown><script type="text/template">


#### Avantages des tuiles vectorielles

* Changement de style dynamique sans avoir besoin de reg√©n√©rer les tuiles
* Un m√™me jeu de tuiles pour diff√©rents contextes
* Affichage des diff√©rentes propri√©t√©s d'un objet
* Rendu possible en 3D

- Exemples:
   - [√Çge des batiments aux Pays Bas ](https://parallel.co.uk/netherlands/#13.8/52.365/4.9/0/40) 

   - [Clustering properties with Mapbox and HTML markers](https://labs.mapbox.com/narratives/cluster-properties/?utm_medium=blog&utm_source=mapbox-blog&utm_campaign=blog|mapbox-blog|maps|clustering-properties-with-mapbox-and-html-markers-bb353c8662ba-19-04&utm_term=maps&utm_content=clustering-properties-with-mapbox-and-html-markers-bb353c8662ba)

</script></section><section data-markdown><script type="text/template">


##### Autres avantages

* Requ√™tes instantan√©es sur les objets 
* Acc√®s √† la g√©om√©trie et aux propri√©t√©s
* Op√©ration g√©om√©triques sur les objets (ex : cluster, vorono√Ø etc.)
* Poids r√©duit
* La carte peut √™tre rendue √† n'importe quelle √©chelle

</script></section><section data-markdown><script type="text/template">

#### G√©n√©ration de tuiles vectorielle

Il y a deux √©tapes pour servir des tuiles vectorielles:
* La premi√®re est d‚Äôex√©cuter les requ√™tes SQL pour obtenir les donn√©es, puis construire les fichiers binaires de tuiles vectorielles proprement dite.
* La seconde est de les servir au travers d‚Äôun serveur web.

Il y a donc des outils qui ne font que la **production des tuiles**, d‚Äôautres qui ne font que le **service web**, et certain qui font les deux (Postile, de l‚Äô√©cosyst√®me du projet OpenMapTiles, Tessera, T-Rex, Tegola)


</script></section><section data-markdown><script type="text/template">


#### √âtapes de production de tuiles vectorielles

* Donn√©es en entr√©e : fichiers OSM (PBF), GeoJSON ou bien une base de donn√©es Postgresql/PostGIS
* Nettoyage des donn√©es en couches d'informations (POI, b√¢timents, rivi√®res) et on ne retient que quelques champs
* On indique √† quel(s) niveaux de zoom les tuiles vont contenir quelle(s) couche(s)
* On s√©rialise le r√©sultat dans un format MVT (binaire)
* On pr√©g√©n√®re les tuiles et soit :
        - on les stocke √† plat
        - soit dans un fichier MBtiles 
 
</script></section><section data-markdown><script type="text/template">

#### G√©n√©ration de tuiles vectorielles

Le **MVT** est une succession de plusieurs couches encod√©es pfb.

* Les MVT peuvent √©galement √™tre g√©n√©r√©s √† l'aide de la fonction PostGIS __ST_AsMVT__.
* Depuis Postgis 3, les performances de g√©n√©rations de tuiles ont √©t√© consid√©rablement am√©lior√©es.
* La fonction ST_AsMVT() a √©t√© rendue parall√©lisable de sorte qu'on peut r√©partir le travail sur plusieurs processeurs, acc√©l√©rant ainsi la g√©n√©ration de tuiles avec beaucoup de g√©om√©tries d'entr√©e.

>La prise en charge des tuiles vectorielles PostGIS est devenue si bonne que m√™me les projets avec des exigences de g√©n√©ration de tuiles massives, comme le projet OpenMapTiles, ont standardis√© leur tuilage sur PostGIS. 
Paul Ramsey - [Waiting for PostGIS 3: ST_AsMVT Performance](http://blog.cleverelephant.ca/2019/08/postgis-3-mvt.html) 



</script></section><section data-markdown><script type="text/template">
### Pratique 

#### G√©n√©ration de tuiles vectorielles

- **Exercice 9 : Tuiles vectorielles** : Se reporter au PDF formation-postgis/activites/*exercices-serie-9.pdf*
	- 9.1 Production de tuiles avec ST_AsMVT()

</script></section><section data-markdown><script type="text/template">
#### Pour aller plus loin

- [Tour d'horizon des serveurs de tuiles vectorielles pour fonds de carte (Makina Corpus)](https://makina-corpus.com/blog/metier/2019/tour-d-horizon-des-serveurs-de-tuiles-vectorielle-pour-fond-de-carte) 
- [Profil d'√©l√©vation avec des tuiles vectorielles (Makina Corpus)](https://makina-corpus.com/blog/metier/2016/profil-delevation-avec-des-tuiles-vectorielles) 

</script></section></section><section ><section data-markdown><script type="text/template">## Exemple d'application

### G√©n√©rer de tuiles vecteur avec PostGIS et t-rex

</script></section><section data-markdown><script type="text/template">
## Pr√©sentation

### Qu'est-ce que t-rex?

Dans leur site: _"Create and serve your own vector tiles"_

- Outil en libre acc√®s
- Fonctionne en ligne de commandes
- Permet g√©n√©rer de _tuiles vecteur_ √† partir de diff√©rentes sources de donn√©es et notamment √† partir des __donn√©es stock√©es dans une base PostGIS__
- Int√®gre plusieurs _snippets_ pour la visualisation des tuiles (`Mapbox GL JS`, `OpenLayers`)

Les __tuiles vecteur__ commencent √† √™tre tr√®s utilis√©es dans le monde du _WebMapping_
Une presentation introductive aux tuiles vectorielles est disponible [ici](https://mtes-mct.github.io/numerique/geek-lunch/2018/05/15/geek-lunch-Makina_Corpus.html)

</script></section><section data-markdown><script type="text/template">
### Installation

t-rex est disponible au [t√©l√©chargement](https://t-rex.tileserver.ch/doc/setup/) sur:

  - Ubuntu
  - Windows
-  Disponible aussi comme image Docker

</script></section><section data-markdown><script type="text/template">
## Mise en place de l'outil

### Deux modes de fonctionnement

- `t-rex` en mode **serve** permet de g√©n√©rer les tuiles √† la vol√©e √† partir de nos donn√©es spatiales stock√©es dans une base PostGIS:

<sub>` t_rex serve --dbconn postgresql://user:pass@localhost/dbname `<sub>

- Il est √©galement possible de pr√©g√©nerer les tuiles avec **generate** :  

` t_rex generate [OPTIONS] `

L'option `--config <FILE>` permet d'utiliser un fichier de configuration customis√© pour la g√©n√©ration de tuiles, et c'est dans celui-ci que se placeront les requ√™tes SQL.


</script></section><section data-markdown><script type="text/template">
### G√©n√©rer et comprendre le fichier de configuration

- t-rex g√©n√®re une configuration par d√©faut √† partir des donn√©es
- Configuration en [format __.TOML__](https://github.com/toml-lang/toml)
- Structure hi√©rarchis√©e de couches en groupes

**Configuration g√©n√©r√©e par d√©faut √† partir d'une base minimale:**
```toml
# t-rex configuration

[service.mvt]
viewer = true

[[datasource]]
dbconn = "postgresql://postgres:postgres@localhost/empty"
name = "dbconn"
default = true

[grid]
# Predefined grids: web_mercator, wgs84
predefined = "web_mercator"

[[tileset]]
name = "empty"
#extent = [-180.0,-90.0,180.0,90.0]
[[tileset.layer]]
name = "empty"
table_name = "empty"
geometry_field = "geom"
geometry_type = "POINT"
srid = 4326
#fid_field = "id"
#tile_size = "4096"
buffer_size = 0
query_limit = 1000
#[[tileset.layer.query]]
#sql = """SELECT ST_Transform(geom,3857) AS geom,"id" FROM empty WHERE geom && !bbox!"""

#[cache.file]
#base = "/tmp/mvtcache"
#baseurl = "http://example.com/tiles"

[webserver]
# Bind address. Use 0.0.0.0 to listen on all adresses.
bind = "127.0.0.1"
port = 6767
threads = 4
#cache_control_max_age = 43200
```

</script></section><section data-markdown><script type="text/template">
### Personnaliser la configuration

Il est possible de **modifier la configuration g√©n√©r√©e par d√©faut par `t-rex`** pour l'adapter √† nos besoins, comme:
- Simplification de g√©ometries
- Affichage s√©lectif d'objets
- S√©lectionner des objects selon le niveau de zoom, prennant comme r√©f√©rence une valeur de ses attributs: routes principales, secondaires, chemins...
- Application d'un style (support experimental pour `Mapbox GL JS`)

</script></section><section data-markdown><script type="text/template">
Pour l'√©criture de la requ√™te, on peut se servir de **variables** :
 - ```!bbox!```
 - ```!zoom!```
 - ```!scale_denominator!```
 - ```!pixel_width!```

</script></section><section data-markdown><script type="text/template">
### Exemple de requ√™tes SQL

Les requ√™tes SQL se construisent au niveau du _layer_:
```toml
[[tileset.layer.query]]
  minzoom = 0
  sql = """
    SELECT name, type, 0 as osm_id, ST_Union(geometry) AS geometry
    FROM osm_buildings_gen0
    WHERE geometry && !bbox!
    GROUP BY name, type
    ORDER BY sum(area) DESC"""
[[tileset.layer.query]]
  minzoom = 17
  maxzoom = 22
  sql = """
    SELECT name, type, osm_id, geometry
    FROM osm_buildings
    WHERE geometry && !bbox!
    ORDER BY area DESC"""
```</script></section></section></div>
    </div>

    <script src="./dist/reveal.js"></script>

    <script src="./plugin/markdown/markdown.js"></script>
    <script src="./plugin/highlight/highlight.js"></script>
    <script src="./plugin/zoom/zoom.js"></script>
    <script src="./plugin/notes/notes.js"></script>
    <script src="./plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"transition":"slide"}, queryOptions);
    </script>


    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
